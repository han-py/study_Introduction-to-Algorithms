# 矩阵链乘法 (Matrix Chain Multiplication)

## 1. 算法简介

矩阵链乘法问题（Matrix Chain Multiplication）是《算法导论》第15章动态规划中讨论的一个经典问题。该问题关注的是如何通过加括号的方式最小化标量乘法的次数来计算一系列矩阵的乘积。

矩阵乘法是线性代数中的基本运算，但其计算代价较高。对于两个矩阵相乘，如果第一个矩阵是p×q的，第二个矩阵是q×r的，那么它们的乘积是一个p×r的矩阵，需要进行p×q×r次标量乘法运算。

当我们需要计算多个矩阵的连乘积时，不同的加括号方式会导致计算代价的巨大差异。矩阵链乘法问题的目标就是找出计算矩阵连乘积的最优加括号方式，使得总的标量乘法次数最少。

## 2. 问题描述

给定一个n个矩阵的序列<A₁, A₂, ..., Aₙ>，其中对于i=1,2,...,n，矩阵Aᵢ的维数为pᵢ₋₁×pᵢ。我们希望计算它们的乘积：

A₁A₂...Aₙ

由于矩阵乘法满足结合律，所以可以通过加括号来确定计算顺序。我们的目标是找出使标量乘法次数最少的加括号方式。

例如，考虑三个矩阵A₁、A₂、A₃，维度分别为10×100、100×5和5×50。有两种加括号方式：

1. ((A₁A₂)A₃)：先计算A₁A₂，再与A₃相乘
   - A₁A₂的计算代价：10×100×5 = 5000次标量乘法
   - (A₁A₂)A₃的计算代价：10×5×50 = 2500次标量乘法
   - 总代价：7500次标量乘法

2. (A₁(A₂A₃))：先计算A₂A₃，再与A₁相乘
   - A₂A₃的计算代价：100×5×50 = 25000次标量乘法
   - A₁(A₂A₃)的计算代价：10×100×50 = 50000次标量乘法
   - 总代价：75000次标量乘法

显然，第一种加括号方式要优于第二种。

## 3. 算法思想

### 3.1 暴力搜索方法的问题

如果我们试图通过枚举所有可能的加括号方式来解决问题，会发现加括号方式的数量与卡塔兰数（Catalan Number）有关，约为Ω(4ⁿ/n³/²)，这是一个指数级的增长，不适合解决大规模问题。

### 3.2 动态规划方法

矩阵链乘法问题具有最优子结构性质，适合用动态规划来解决。我们可以按照以下步骤来设计算法：

1. **刻画最优解的结构特征**：对于矩阵链AᵢAᵢ₊₁...Aⱼ，任何加括号方式都会在Aₖ和Aₖ₊₁之间将链分开（i≤k<j），然后分别计算子链Aᵢ...Aₖ和Aₖ₊₁...Aⱼ的乘积，最后将这两个结果相乘。

2. **递归地定义最优解的值**：令m[i,j]表示计算矩阵Aᵢ...Aⱼ所需的标量乘法次数的最小值。如果i=j，则m[i,j]=0；如果i<j，则：
   ```
   m[i,j] = min{m[i,k] + m[k+1,j] + pᵢ₋₁×pₖ×pⱼ}  (i≤k<j)
   ```

3. **计算最优解的值**：使用自底向上的方法填表，从小长度的子链开始计算。

4. **构造最优解**：通过记录分割点来构造最优加括号方案。

## 4. 算法步骤

### 4.1 建立递归关系

对于矩阵链<Aᵢ, Aᵢ₊₁, ..., Aⱼ>，我们定义m[i,j]为计算AᵢAᵢ₊₁...Aⱼ所需的最小标量乘法次数：

- 如果i=j（只有一个矩阵），则m[i,j]=0
- 如果i<j，则：
  ```
  m[i,j] = min{m[i,k] + m[k+1,j] + pᵢ₋₁×pₖ×pⱼ}  其中i≤k<j
  ```

其中pᵢ₋₁×pₖ×pⱼ是计算(Aᵢ...Aₖ)(Aₖ₊₁...Aⱼ)所需的标量乘法次数。

### 4.2 构造DP表

我们使用一个二维表m[1..n,1..n]来保存子问题的解，其中m[i,j]表示计算Aᵢ...Aⱼ的最小代价。

同时，我们需要另一个表s[1..n-1,2..n]来记录最优分割点，即s[i,j]记录了k值，使得(Aᵢ...Aₖ)(Aₖ₊₁...Aⱼ)是最优的分割方式。

### 4.3 填表过程

填表过程按子问题的规模（链长）从小到大进行：

1. 链长为1时，m[i,i]=0
2. 链长为2时，计算m[i,i+1]
3. 链长为3时，计算m[i,i+2]
4. 以此类推，直到计算出m[1,n]

## 5. 伪代码实现

```
MATRIX-CHAIN-ORDER(p)
    n = p.length - 1
    let m[1..n,1..n] and s[1..n-1,2..n] be new tables
    for i = 1 to n
        m[i,i] = 0
    for l = 2 to n     // l is the chain length
        for i = 1 to n-l+1
            j = i + l - 1
            m[i,j] = ∞
            for k = i to j-1
                q = m[i,k] + m[k+1,j] + p[i-1]*p[k]*p[j]
                if q < m[i,j]
                    m[i,j] = q
                    s[i,j] = k
    return m and s
```

## 6. 算法图解示例

以矩阵序列<p₀=30, p₁=35, p₂=15, p₃=5, p₄=10, p₅=20, p₆=25>为例，对应6个矩阵：
- A₁: 30×35
- A₂: 35×15
- A₃: 15×5
- A₄: 5×10
- A₅: 10×20
- A₆: 20×25

### 6.1 DP表填充过程

我们将逐步填充m表，其中m[i][j]表示计算矩阵Aᵢ到Aⱼ的最小标量乘法次数：

1. 链长为1：m[1,1]=m[2,2]=...=m[6,6]=0

2. 链长为2：
   - m[1,2] = m[1,1] + m[2,2] + 30×35×15 = 0 + 0 + 15750 = 15750
   - m[2,3] = m[2,2] + m[3,3] + 35×15×5 = 0 + 0 + 2625 = 2625
   - ...

3. 链长为3：
   - m[1,3] = min{
       m[1,1]+m[2,3]+30×35×5 = 0+2625+5250 = 7875,
       m[1,2]+m[3,3]+30×15×5 = 15750+0+2250 = 18000
     } = 7875，分割点k=1

### 6.2 最终结果

通过完整的填表过程，我们得到最小标量乘法次数为15125，最优加括号方案为：
((A₁(A₂A₃))((A₄A₅)A₆))

## 7. C++代码实现

详见 [MatrixChainMultiplication.cpp](MatrixChainMultiplication.cpp) 文件。

## 8. 算法分析

### 8.1 时间复杂度

算法中有三重嵌套循环：
- 最外层循环链长l执行n-1次
- 中间层循环起点i最多执行n-l+1次
- 最内层循环分割点k最多执行j-i次，即l-1次

总的时间复杂度为O(n³)。

### 8.2 空间复杂度

算法使用了两个二维表m和s，每个表的大小都是n×n，因此空间复杂度为O(n²)。

### 8.3 稳定性

矩阵链乘法问题不是一个排序问题，因此稳定性的概念不适用。

## 9. 算法特点

### 9.1 优点

1. **高效性**：将指数时间复杂度降低到多项式时间复杂度O(n³)
2. **通用性**：适用于任意长度的矩阵链
3. **最优性**：能够保证找到全局最优解
4. **实用性**：在实际应用中具有重要价值

### 9.2 缺点

1. **空间需求**：需要O(n²)的额外空间来存储DP表
2. **适用范围**：只适用于具有最优子结构的问题

## 10. 适用场景

1. **图形学**：在3D图形变换中经常需要计算多个变换矩阵的连乘积
2. **数值计算**：在科学计算中处理大型矩阵运算
3. **机器学习**：在神经网络训练中进行矩阵运算优化
4. **编译器优化**：在编译器中优化数组访问的计算顺序

## 11. 与其他算法的比较

| 算法 | 时间复杂度 | 空间复杂度 | 特点 |
|------|------------|------------|------|
| 暴力搜索 | O(4ⁿ/n³/²) | O(n) | 指数时间，不实用 |
| 动态规划 | O(n³) | O(n²) | 多项式时间，最优解 |
| 近似算法 | O(n²)或更低 | O(n) | 快速但不保证最优解 |

## 12. 优化方案

1. **记忆化搜索**：使用自顶向下的递归方式配合记忆化技术
2. **空间优化**：如果只需要最优值而不需要构造解，可以优化空间复杂度
3. **并行化**：在多核环境下并行计算不同长度的子问题
4. **缓存优化**：优化内存访问模式以提高缓存命中率

矩阵链乘法问题是动态规划的经典应用之一，展示了如何通过识别问题的最优子结构性质来设计高效的算法解决方案。