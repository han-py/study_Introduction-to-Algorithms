# 最优二叉搜索树 (Optimal Binary Search Tree, OBST)

## 1. 算法简介

最优二叉搜索树（Optimal Binary Search Tree，OBST）是《算法导论》第15章中讨论的另一个重要动态规划问题。该问题旨在构造一棵二叉搜索树，使得在给定关键字搜索概率的情况下，搜索的期望代价最小。

### 🎯 什么是二叉搜索树？

二叉搜索树（Binary Search Tree，BST）是一种重要的数据结构，具有以下性质：
1. 若左子树不空，则左子树上所有节点的值均小于根节点的值
2. 若右子树不空，则右子树上所有节点的值均大于根节点的值
3. 左、右子树也分别为二叉搜索树

### 🤔 什么是最优二叉搜索树？

在实际应用中，不同关键字的搜索频率往往是不同的。最优二叉搜索树问题考虑了这种差异，通过合理安排关键字在树中的位置，使得整体搜索代价最小。

例如，假设我们有一个字典应用，常用词汇（如"a"、"the"）的搜索频率远高于生僻词（如"xylophone"），那么我们应该将常用词放在靠近根节点的位置，以减少平均搜索时间。

### 💡 实际应用场景

1. **字典应用**：根据单词使用频率优化查找速度
2. **编译器设计**：优化标识符查找效率
3. **数据库索引**：根据数据访问频率优化索引结构
4. **自动补全系统**：根据用户输入习惯优化提示词排序
5. **搜索引擎**：优化热门搜索词的响应速度

## 2. 问题描述

给定一个已排序的关键字序列 K = <k₁, k₂, ..., kₙ>，其中 k₁ < k₂ < ... < kₙ，对于每个关键字 kᵢ，有一个搜索概率 pᵢ。此外，还有 n+1 个"伪关键字"表示搜索失败的情况：d₀ 表示所有小于 k₁ 的值，dᵢ 表示所有在 kᵢ 和 kᵢ₊₁ 之间的值（1 ≤ i ≤ n-1），dₙ 表示所有大于 kₙ 的值，每个伪关键字 dᵢ 有搜索概率 qᵢ。

我们的目标是构造一棵二叉搜索树，使得搜索期望代价最小。

### 🔍 搜索代价的计算

在一棵二叉搜索树中，一次搜索的代价等于访问的节点数，即从根节点到目标节点的路径长度加1。期望搜索代价是所有情况（成功搜索和失败搜索）代价的加权平均：

```
期望搜索代价 = Σ(i=1 to n)[depth(kᵢ)+1] × pᵢ + Σ(i=0 to n)[depth(dᵢ)+1] × qᵢ
```

其中 depth(x) 表示节点 x 在树中的深度（根节点深度为0）。

### 📘 一个具体例子

考虑以下关键字和概率分布：

| 关键字 | 搜索概率 |
|--------|----------|
| k₁ = A | 0.2      |
| k₂ = B | 0.3      |
| k₃ = C | 0.5      |

| 伪关键字 | 搜索概率 |
|----------|----------|
| d₀       | 0.1      |
| d₁       | 0.1      |
| d₂       | 0.1      |
| d₃       | 0.1      |

我们可以构造多种不同的二叉搜索树，但只有一种能使期望搜索代价最小。

## 3. 算法思想

### ❌ 暴力搜索方法的问题

如果我们试图通过枚举所有可能的二叉搜索树来解决问题，会发现这种方法非常低效：

1. n个节点的不同二叉搜索树数量为第n个卡塔兰数：C(n) = (2n)! / ((n+1)! × n!)
2. 即使对于较小的n，这个数量也非常庞大
3. 时间复杂度为指数级，不适合解决大规模问题

显然，暴力搜索不是解决问题的好方法。

### ✅ 动态规划方法（聪明的做法）

最优二叉搜索树问题具有最优子结构性质，适合用动态规划来解决。我们可以按照以下步骤来设计算法：

#### 3.1 最优子结构

考虑包含关键字 kᵢ, kᵢ₊₁, ..., kⱼ 的一棵最优子树 T。设该子树的根节点为 kᵣ（i ≤ r ≤ j），则：
1. 左子树包含关键字 kᵢ, kᵢ₊₁, ..., kᵣ₋₁，且必须是包含这些关键字的最优子树
2. 右子树包含关键字 kᵣ₊₁, kᵣ₊₂, ..., kⱼ，且必须是包含这些关键字的最优子树

这意味着原问题的最优解包含了子问题的最优解——这就是所谓的最优子结构。

#### 3.2 重叠子问题

在递归地解决这个问题时，我们会多次遇到相同的子问题。例如，在计算包含关键字{k₁, k₂, k₃, k₄}的最优子树时，可能会多次用到包含{k₂, k₃}的子问题。

动态规划通过存储子问题的解来避免重复计算，大大提高了效率。

## 4. 算法步骤详解

### 4.1 建立递归关系

我们定义以下符号：
- e[i, j]：包含关键字 kᵢ, kᵢ₊₁, ..., kⱼ 的子树的期望搜索代价
- w[i, j]：概率之和 pᵢ + ... + pⱼ + qᵢ₋₁ + ... + qⱼ

递归关系如下：

```
e[i, j] = 0                                如果 j = i-1
e[i, j] = min(e[i, r-1] + e[r+1, j] + w[i, j])  如果 i ≤ j
```

其中 r 是根节点的选择（i ≤ r ≤ j），w[i, j] 是子树中所有概率的和。

### 4.2 构造DP表

我们使用二维表 e[1..n+1, 0..n] 来保存子问题的解，其中 e[i, j] 表示包含关键字 kᵢ 到 kⱼ 的子树的最小期望搜索代价。

同时，我们需要另一个表 root[1..n, 1..n] 来记录每个子问题的最优根节点选择。

### 4.3 填表过程

填表过程按子问题的规模（关键字数量）从小到大进行：

1. 规模为0时：e[i, i-1] = qᵢ₋₁（只有伪关键字 dᵢ₋₁）
2. 规模为1时：计算 e[i, i]（包含一个关键字和两个伪关键字）
3. 规模为2时：计算 e[i, i+1]（包含两个关键字和三个伪关键字）
4. 以此类推，直到计算出 e[1, n]

这种自底向上的方法确保在计算较大问题时，所需的子问题解已经计算出来了。

## 5. 伪代码实现

```
OPTIMAL-BST(p, q, n)
    let e[1..n+1, 0..n], w[1..n+1, 0..n], and root[1..n, 1..n] be new tables
    
    // 初始化边界条件
    for i = 1 to n+1
        e[i, i-1] = q[i-1]
        w[i, i-1] = q[i-1]
    
    // 按子问题规模从小到大计算
    for len = 1 to n
        for i = 1 to n-len+1
            j = i + len - 1
            e[i, j] = ∞
            w[i, j] = w[i, j-1] + p[j] + q[j]
            
            // 尝试每个可能的根节点
            for r = i to j
                t = e[i, r-1] + e[r+1, j] + w[i, j]
                if t < e[i, j]
                    e[i, j] = t
                    root[i, j] = r
    
    return e and root
```

## 6. 算法图解示例

以《算法导论》图15-9中的例子为例：

### 6.1 输入数据

关键字和搜索概率：
| 关键字 | 搜索概率 |
|--------|----------|
| k₁ = k₁ | 0.15     |
| k₂ = k₂ | 0.10     |
| k₃ = k₃ | 0.05     |
| k₄ = k₄ | 0.10     |
| k₅ = k₅ | 0.20     |

伪关键字和搜索概率：
| 伪关键字 | 搜索概率 |
|----------|----------|
| d₀       | 0.05     |
| d₁       | 0.10     |
| d₂       | 0.05     |
| d₃       | 0.05     |
| d₄       | 0.05     |
| d₅       | 0.10     |

### 6.2 DP表填充过程

我们将逐步填充 e 表，其中 e[i][j] 表示包含关键字 kᵢ 到 kⱼ 的子树的最小期望搜索代价：

1. 规模为0：
   - e[1,0] = q₀ = 0.05
   - e[2,1] = q₁ = 0.10
   - ...

2. 规模为1：
   - e[1,1] = e[1,0] + e[2,1] + w[1,1] = 0.05 + 0.10 + (0.15+0.05+0.10) = 0.45
   - e[2,2] = e[2,1] + e[3,2] + w[2,2] = 0.10 + 0.05 + (0.10+0.05+0.05) = 0.35
   - ...

3. 规模为2：
   - e[1,2] = min{
       e[1,0] + e[2,2] + w[1,2] = 0.05 + 0.35 + 0.45 = 0.85,
       e[1,1] + e[3,2] + w[1,2] = 0.45 + 0.05 + 0.45 = 0.95
     } = 0.85，根节点为k₂
   - ...

### 6.3 最终结果

通过完整的填表过程，我们得到最小期望搜索代价为2.75，最优二叉搜索树结构如下：

```
      k₂
     /  \
    k₁   k₄
        /  \
       k₃   k₅
```

## 7. C++代码实现详解

详见 [OptimalBinarySearchTree.cpp](OptimalBinarySearchTree.cpp) 文件，代码中有详细的注释和执行过程输出，非常适合学习理解。

### 7.1 核心函数解析

#### optimalBST 函数
这是算法的核心，它实现了上述的动态规划过程：
1. 初始化DP表和辅助表
2. 按子问题规模从小到大填表
3. 对每个子问题尝试所有可能的根节点选择
4. 记录最优解和根节点选择

#### printOptimalBST 函数
根据记录的根节点表递归地构造并打印最优二叉搜索树结构。

## 8. 算法分析

### 8.1 时间复杂度

算法中有三重嵌套循环：
- 最外层循环子问题规模 len 执行 n 次
- 中间层循环起点 i 最多执行 n-len+1 次
- 最内层循环根节点 r 最多执行 j-i+1 次

总的时间复杂度为 O(n³)。

### 8.2 空间复杂度

算法使用了三个二维表 e、w 和 root，每个表的大小都是 (n+1)×(n+1)，因此空间复杂度为 O(n²)。

### 8.3 稳定性

最优二叉搜索树问题不是一个排序问题，因此稳定性的概念不适用。

## 9. 算法特点

### ✅ 优点

1. **高效性**：将指数时间复杂度降低到多项式时间复杂度 O(n³)
2. **实用性**：在实际应用中具有重要价值
3. **精确性**：能够保证找到全局最优解
4. **灵活性**：可以根据不同的概率分布构造不同的树结构

### ❌ 缺点

1. **空间需求**：需要 O(n²) 的额外空间来存储DP表
2. **预处理要求**：需要预先知道所有关键字的搜索概率
3. **静态性**：一旦构造完成，难以动态调整

## 10. 适用场景

1. **字典软件**：根据单词使用频率优化查询速度
2. **编译器优化**：优化符号表查找效率
3. **数据库系统**：根据访问模式优化索引结构
4. **推荐系统**：根据用户偏好优化内容展示顺序
5. **操作系统**：优化系统调用处理顺序

## 11. 与其他算法的比较

| 算法 | 时间复杂度 | 空间复杂度 | 特点 |
|------|------------|------------|------|
| 暴力搜索 | O(4ⁿ/n^(3/2)) | O(n) | 指数时间，不实用 |
| 动态规划 | O(n³) | O(n²) | 多项式时间，最优解 |
| 贪心算法 | O(n log n) | O(n) | 快速但不保证最优解 |

## 12. 优化方案

1. **空间优化**：如果只需要最优值而不需要构造树，可以优化空间复杂度
2. **Knuth优化**：利用最优二叉搜索树的单调性，将时间复杂度优化到 O(n²)
3. **并行化**：在多核环境下并行计算不同规模的子问题
4. **近似算法**：对于超大规模问题，可以考虑使用近似算法

## 13. 学习建议

对于初学者，建议按以下步骤学习最优二叉搜索树问题：

1. **理解问题背景**：先搞清楚为什么需要研究这个问题
2. **掌握基础知识**：理解二叉搜索树的基本概念和性质
3. **学习暴力方法**：了解暴力搜索的思路及为什么不可行
4. **理解动态规划**：掌握动态规划的基本思想和适用条件
5. **分析具体例子**：通过手动计算小例子加深理解
6. **阅读代码实现**：结合代码理解算法执行过程
7. **动手实践**：修改参数，观察结果变化

最优二叉搜索树问题是动态规划的经典应用之一，展示了如何通过识别问题的最优子结构性质来设计高效的算法解决方案。掌握了这个问题，你会对动态规划有更深入的理解。