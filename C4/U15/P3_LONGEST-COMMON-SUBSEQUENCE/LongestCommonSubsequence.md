# 最长公共子序列 (Longest Common Subsequence, LCS)

## 1. 算法简介

最长公共子序列（Longest Common Subsequence，LCS）是《算法导论》第15章中讨论的一个重要动态规划问题。该问题旨在找出两个序列中最长的公共子序列。

### 🎯 什么是子序列？

子序列是从原序列中删除若干元素（也可以不删除）后得到的新序列，**元素的相对顺序保持不变**，但**不要求连续**。

例如，对于序列"ABCDE"：
- "ACE"是它的子序列（删除B和D）
- "ACDE"是它的子序列（删除B）
- "AEC"不是它的子序列（因为改变了元素的相对顺序）

### 🤔 什么是最长公共子序列？

给定两个序列X和Y，最长公共子序列是**既是X的子序列又是Y的子序列的最长序列**。

例如，对于序列X="ABCBDAB"和Y="BDCABA"：
- "BCA"是它们的公共子序列
- "BCBA"也是它们的公共子序列
- "BCAB"是它们的最长公共子序列，长度为4

### 💡 实际应用场景

1. **文本比较工具**：如Git、Diff等工具使用LCS算法来比较文件差异
2. **生物信息学**：DNA序列比对，寻找基因序列的相似性
3. **版本控制系统**：合并不同分支的代码变更
4. **抄袭检测**：比较两份文档的相似度
5. **数据压缩**：在某些压缩算法中用于寻找重复模式

## 2. 算法思想

### ❌ 暴力搜索方法的问题

如果我们尝试通过枚举所有可能的子序列来解决问题，会发现这种方法非常低效：

1. 长度为n的序列有2ⁿ个子序列
2. 对于两个序列，需要比较2ᵐ × 2ⁿ种组合
3. 时间复杂度为O(2ᵐ⁺ⁿ)，这是指数级的复杂度

显然，暴力搜索不是解决问题的好方法。

### ✅ 动态规划方法（聪明的做法）

LCS问题具有最优子结构性质，适合用动态规划来解决。我们可以按照以下步骤来设计算法：

#### 2.1 最优子结构

设序列X[0..m-1]和Y[0..n-1]的LCS长度为LCS(X, Y)。

- 如果X[m-1] == Y[n-1]，则LCS(X, Y) = LCS(X[0..m-2], Y[0..n-2]) + 1
- 如果X[m-1] != Y[n-1]，则LCS(X, Y) = max(LCS(X[0..m-2], Y[0..n-1]), LCS(X[0..m-1], Y[0..n-2]))

这意味着原问题的最优解包含了子问题的最优解——这就是所谓的最优子结构。

#### 2.2 重叠子问题

在递归地解决这个问题时，我们会多次遇到相同的子问题。例如，在计算LCS("ABCD", "ACD")时，LCS("A", "A")这个子问题会被多次用到。

动态规划通过存储子问题的解来避免重复计算，大大提高了效率。

## 3. 算法步骤详解

### 3.1 建立递归关系

我们定义c[i][j]为序列X[0..i-1]和Y[0..j-1]的LCS长度：

```
c[i][j] = 0                                      如果 i=0 或 j=0
c[i][j] = c[i-1][j-1] + 1                       如果 i,j>0 且 X[i-1]=Y[j-1]
c[i][j] = max(c[i-1][j], c[i][j-1])             如果 i,j>0 且 X[i-1]≠Y[j-1]
```

### 3.2 构造DP表

我们使用一个二维表c[0..m, 0..n]来保存子问题的解，其中c[i][j]表示X[0..i-1]和Y[0..j-1]的LCS长度。

同时，为了能够重构实际的LCS序列，我们还需要一个方向表b[1..m, 1..n]来记录每个子问题的决策：

```
b[i][j] = '\\'  如果X[i-1] = Y[j-1]
b[i][j] = '|'   如果c[i][j] = c[i-1][j]
b[i][j] = '-'   如果c[i][j] = c[i][j-1]
```

### 3.3 填表过程

填表过程按从上到下、从左到右的顺序进行：

1. 初始化第0行和第0列为0
2. 对于每个位置(i,j)：
   - 如果X[i-1] = Y[j-1]，则c[i][j] = c[i-1][j-1] + 1
   - 否则c[i][j] = max(c[i-1][j], c[i][j-1])

### 3.4 重构LCS序列

通过回溯方向表b可以重构实际的LCS序列：

1. 从b[m][n]开始
2. 如果b[i][j] = '\\'，则X[i-1]（或Y[j-1]）是LCS的一个字符，继续回溯b[i-1][j-1]
3. 如果b[i][j] = '|'，继续回溯b[i-1][j]
4. 如果b[i][j] = '-'，继续回溯b[i][j-1]
5. 直到i=0或j=0为止

## 4. 伪代码实现

```
LCS-LENGTH(X, Y)
    m = X.length
    n = Y.length
    let c[0..m, 0..n] and b[1..m, 1..n] be new tables
    
    // 初始化边界条件
    for i = 0 to m
        c[i, 0] = 0
    for j = 0 to n
        c[0, j] = 0
    
    // 填充DP表
    for i = 1 to m
        for j = 1 to n
            if X[i-1] == Y[j-1]
                c[i, j] = c[i-1, j-1] + 1
                b[i, j] = '\\'
            else if c[i-1, j] >= c[i, j-1]
                c[i, j] = c[i-1, j]
                b[i, j] = '|'
            else
                c[i, j] = c[i, j-1]
                b[i, j] = '-'
    
    return c and b

PRINT-LCS(b, X, i, j)
    if i == 0 or j == 0
        return
    if b[i, j] == '\\'
        PRINT-LCS(b, X, i-1, j-1)
        print X[i-1]
    else if b[i, j] == '|'
        PRINT-LCS(b, X, i-1, j)
    else
        PRINT-LCS(b, X, i, j-1)
```

## 5. 算法图解示例

以序列X="ABCBDAB"和Y="BDCABA"为例，演示LCS算法的执行过程：

### 5.1 DP表填充过程

我们将逐步填充c表，其中c[i][j]表示X[0..i-1]和Y[0..j-1]的LCS长度：

|   |   | B | D | C | A | B | A |
|---|---|---|---|---|---|---|---|
|   | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| A | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| B | 0 | 1 | 1 | 1 | 1 | 2 | 2 |
| C | 0 | 1 | 1 | 2 | 2 | 2 | 2 |
| B | 0 | 1 | 1 | 2 | 2 | 3 | 3 |
| D | 0 | 1 | 2 | 2 | 2 | 3 | 3 |
| A | 0 | 1 | 2 | 2 | 3 | 3 | 4 |
| B | 0 | 1 | 2 | 2 | 3 | 4 | 4 |

### 5.2 方向表

方向表b可以帮助我们重构LCS序列：

|   |   | B | D | C | A | B | A |
|---|---|---|---|---|---|---|---|
| A |   | \\| - | - | \\| | | \\|
| B |   | \\| - | - | | | \\| - |
| C |   | | | \\| - | - | - | - |
| B |   | | | | | \\| - | - |
| D |   | | \\| - | - | - | - | - |
| A |   | | | | \\| - | - | \\|
| B |   | | | | | \\| - | - |

### 5.3 重构LCS序列

通过回溯方向表，我们可以得到LCS序列"BCAB"：

1. 从b[7][6]开始（值为'\\'），添加'B'到LCS，移动到b[6][5]
2. b[6][5]='\\'，添加'A'到LCS，移动到b[5][4]
3. b[5][4]='\\'，添加'B'到LCS，移动到b[4][3]
4. b[4][3]='\\'，添加'C'到LCS，移动到b[3][2]
5. b[3][2]='\\'，添加'B'到LCS，移动到b[2][1]
6. b[2][1]='\\'，添加'B'到LCS，移动到b[1][0]
7. 到达边界，回溯结束

注意：由于回溯是从后往前构造LCS，所以实际的LCS是"BCAB"。

## 6. C++代码实现详解

详见 [LongestCommonSubsequence.cpp](LongestCommonSubsequence.cpp) 文件，代码中有详细的注释和执行过程输出，非常适合学习理解。

### 6.1 核心函数解析

#### lcsLength 函数
这是算法的核心，它实现了上述的动态规划过程：
1. 初始化DP表和方向表
2. 按照递推关系填充DP表
3. 记录每个子问题的决策方向

#### printLCS 函数
根据记录的方向表递归地构造并打印LCS序列。

## 7. 算法分析

### 7.1 时间复杂度

算法中有两重嵌套循环：
- 外层循环执行m次（X序列的长度）
- 内层循环执行n次（Y序列的长度）
- 每次循环内的操作都是常数时间

总的时间复杂度为O(m×n)。

### 7.2 空间复杂度

算法使用了两个二维表c和b，每个表的大小都是(m+1)×(n+1)，因此空间复杂度为O(m×n)。

### 7.3 稳定性

LCS问题不是一个排序问题，因此稳定性的概念不适用。

## 8. 算法特点

### ✅ 优点

1. **高效性**：将指数时间复杂度降低到多项式时间复杂度O(m×n)
2. **通用性**：适用于任意长度的两个序列
3. **最优性**：能够保证找到全局最优解
4. **实用性**：在实际应用中具有重要价值

### ❌ 缺点

1. **空间需求**：需要O(m×n)的额外空间来存储DP表
2. **适用范围**：只适用于具有最优子结构的问题

## 9. 适用场景

1. **文本编辑器**：实现diff功能，比较两个文件的差异
2. **版本控制系统**：如Git中的文件合并操作
3. **生物信息学**：DNA/RNA序列比对，蛋白质结构分析
4. **数据挖掘**：在时间序列数据中寻找相似模式
5. **自然语言处理**：句子相似度计算，机器翻译评估

## 10. 与其他算法的比较

| 算法 | 时间复杂度 | 空间复杂度 | 特点 |
|------|------------|------------|------|
| 暴力搜索 | O(2ᵐ⁺ⁿ) | O(1) | 指数时间，不实用 |
| 动态规划 | O(m×n) | O(m×n) | 多项式时间，最优解 |
| 空间优化DP | O(m×n) | O(min(m,n)) | 时间相同，空间优化 |

## 11. 优化方案

1. **空间优化**：如果只需要LCS长度而不需要构造序列，可以将空间复杂度优化到O(min(m,n))
2. **滚动数组**：只保留当前行和上一行的计算结果
3. **并行化**：在多核环境下并行计算DP表的不同部分
4. **缓存优化**：优化内存访问模式以提高缓存命中率

## 12. 学习建议

对于初学者，建议按以下步骤学习LCS问题：

1. **理解问题背景**：先搞清楚什么是子序列，什么是最长公共子序列
2. **掌握基础知识**：理解动态规划的基本思想和适用条件
3. **学习暴力方法**：了解暴力搜索的思路及为什么不可行
4. **理解动态规划**：掌握LCS问题的状态转移方程
5. **分析具体例子**：通过手动计算小例子加深理解
6. **阅读代码实现**：结合代码理解算法执行过程
7. **动手实践**：修改参数，观察结果变化

LCS问题是动态规划的经典应用之一，展示了如何通过识别问题的最优子结构性质来设计高效的算法解决方案。掌握了这个问题，你会对动态规划有更深入的理解。