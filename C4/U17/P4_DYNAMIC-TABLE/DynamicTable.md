# 动态表 (Dynamic Tables)

> 📘 _算法导论第17.4节学习指南_

## 🎯 1. 简介

**动态表**(Dynamic Tables)是一种可以根据需要自动调整大小的数据结构。在许多编程语言中，这种概念体现在动态数组（如C++中的`std::vector`或Java中的`ArrayList`）中。

动态表支持两种主要操作：
1. **插入**(INSERT) - 在表中添加元素
2. **删除**(DELETE) - 从表中移除元素

关键挑战在于如何高效地管理表的大小，既要避免浪费空间，又要确保操作效率。

## 🔍 2. 动态表的基本操作

### 2.1 表扩张 (Table Expansion)

当表满了之后再插入元素，我们需要扩张表的大小：

```
TABLE-INSERT(T, x)
1. if T.size == 0
2.     allocate T.table[0...0] // 分配初始空间
3. else if T.num == T.size
4.     allocate new-table[0...2*T.size-1] // 倍增策略
5.     free T.table
6.     T.table = new-table
7.     T.size = 2*T.size
8. T.table[T.num] = x
9. T.num = T.num + 1
```

### 2.2 表收缩 (Table Contraction)

为了回收未使用的空间，当表变得过于稀疏时，我们需要收缩表的大小：

```
TABLE-DELETE(T)
1. if T.num == 0
2.     error "表下溢"
3. T.num = T.num - 1
4. y = T.table[T.num]
5. if T.num == T.size/4  // 使用1/4阈值防止抖动
6.     allocate new-table[0...T.size/2-1]
7.     for i = 0 to T.num-1
8.         new-table[i] = T.table[i]
9.     free T.table
10.    T.table = new-table
11.    T.size = T.size/2
12.return y
```

## 📊 3. 摊还分析

### 3.1 使用核算法分析表扩张

对于表扩张操作，我们可以使用核算法进行分析：

- **实际成本**：普通插入为1，需要扩张的插入为i（如果当前表大小为i-1）
- **摊还成本**：分配$2个信用
  - 1个信用支付实际插入成本
  - 1个信用预存用于将来复制该元素到新表

这样可以保证每个元素最多有一个预存信用用于自身被复制，因此摊还成本为O(1)。

### 3.2 使用势能法分析

定义势函数：Φ(T) = 2·num[T] - size[T]

#### 3.2.1 插入操作分析

**情况1：表未满**
- 实际成本：ĉi = 1
- 势变化：Φi - Φi-1 = 2(num[i] - num[i-1]) - (size[i] - size[i-1]) = 2(1) - 0 = 2
- 摊还成本：ci' = ĉi + Φi - Φi-1 = 1 + 2 = 3 = O(1)

**情况2：表满了需要扩张**
- 设扩张前有i-1个元素，size=i-1
- 实际成本：ĉi = i（插入新元素 + 复制i-1个旧元素）
- 势变化：Φi - Φi-1 = 2(1) - (2(i-1) - (i-1)) = 2 - (i-1) = 3 - i
- 摊还成本：ci' = ĉi + Φi - Φi-1 = i + (3-i) = 3 = O(1)

#### 3.2.2 删除操作分析

**情况1：不需要收缩**
- 实际成本：ĉi = 1
- 势变化：Φi - Φi-1 = 2(-1) - 0 = -2
- 摊还成本：ci' = 1 + (-2) = -1 = O(1)

**情况2：需要收缩**
- 实际成本：ĉi = (size[i-1]/2) + 1
- 势变化：Φi - Φi-1 = 2(-size[i-1]/4) - (-size[i-1]/2) = -size[i-1]/2 + size[i-1]/2 = 0
- 摊还成本：ci' = (size[i-1]/2 + 1) + 0 = O(size[i-1]) = O(num[i])

注意：删除操作的摊还成本不是O(1)，而是O(1)的累积效果。

## 💡 4. 实现要点

### 4.1 扩张策略

常见的扩张策略包括：
1. **倍增策略**：每次扩张为原来的2倍
2. **常数增量策略**：每次增加固定数量的空间

倍增策略提供了更好的摊还性能。

### 4.2 收缩策略

为了避免频繁扩张和收缩导致的"抖动"(thrashing)现象：
- 使用1/2作为扩张阈值（负载因子达到1时扩张）
- 使用1/4作为收缩阈值（负载因子降到1/4时收缩）

这样在阈值之间存在滞后区域，防止抖动。

### 4.3 负载因子

负载因子 α = num/size 表示表的填充程度：
- α = 1：表完全填满
- α = 0.5：表一半填满
- 较高的α值节省空间但可能导致更多冲突
- 较低的α值浪费空间但提供更好性能

## 🧪 5. 示例代码解析

我们的示例代码展示了动态表的核心概念：

1. **类设计**：`DynamicTable`类封装了表的操作
2. **扩张机制**：当元素数等于容量时，调用`expand()`方法将容量加倍
3. **收缩机制**：当负载因子低于0.25时，调用`contract()`方法将容量减半
4. **负载因子监控**：实时显示表的状态信息

## 📈 6. 性能分析

| 操作 | 最坏情况时间复杂度 | 摊还时间复杂度 |
|------|------------------|---------------|
| 插入 | O(n) | O(1) |
| 删除 | O(n) | O(1)* |

*删除操作的摊还分析稍微复杂，但在合理的扩张/收缩策略下仍可视为O(1)

## ⚠️ 7. 注意事项

1. **内存管理**：动态表涉及频繁的内存分配和释放，需要注意内存泄漏
2. **边界条件**：处理空表和单元素表等特殊情况
3. **阈值选择**：扩张和收缩阈值的选择直接影响性能
4. **初始化**：空表的正确初始化很重要

## 📚 8. 相关概念

- **摊还分析**：用于分析一系列操作的平均成本
- **势能法**：一种摊还分析方法，通过势函数衡量数据结构状态
- **负载因子**：衡量哈希表等数据结构填充程度的重要指标

## 🎯 9. 应用场景

动态表广泛应用于各种编程语言的标准库中：
- C++ STL的`std::vector`
- Java的`ArrayList`
- Python的`list`
- JavaScript的`Array`

这些实现都是基于动态表的思想，在实际应用中进行了优化。

## 🧠 10. 总结

动态表是一个重要的数据结构，它展示了如何通过智能的扩张和收缩策略来平衡空间和时间效率。通过摊还分析，我们可以证明尽管某些单独操作可能代价高昂，但整体操作序列仍然具有良好的性能特征。

理解动态表的工作原理有助于更好地使用现代编程语言中的容器类，并为进一步学习高级数据结构打下基础。