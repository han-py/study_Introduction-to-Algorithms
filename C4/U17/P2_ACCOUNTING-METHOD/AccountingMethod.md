# 核算法 (Accounting Method)

> 📘 _算法导论第17.2节学习指南_

## 🎯 1. 简介

**核算法**(Accounting Method)，也被称为**记账方法**或**银行家方法**(Banker's Method)，是摊还分析的第二种方法。与聚合分析不同，核算法为不同的操作分配不同的摊还代价，有些操作的摊还代价可能高于实际代价，而有些则可能低于实际代价。

这种方法的核心思想是：
1. 将摊还代价高于实际代价的差额作为**信用**(credit)存储在数据结构中
2. 当操作的摊还代价低于实际代价时，使用存储的信用来支付差额
3. 确保任何时候数据结构中的总信用保持非负

## 🤔 2. 核算法 vs 聚合分析

| 特性 | 聚合分析 | 核算法 |
|------|----------|--------|
| 操作摊还代价 | 相同 | 可能不同 |
| 信用存储 | 无 | 存储在数据结构中 |
| 分析方式 | 分析整个序列 | 为每个操作单独分配摊还代价 |
| 直观性 | 较弱 | 较强，像记账一样 |

## 📚 3. 核算法定义

核算法遵循以下原则：

> 为每个操作分配一个摊还代价，使得对于任意n个操作的序列，总摊还代价是总实际代价的上界。

形式化表示：
- 设第i个操作的实际代价为cᵢ
- 设第i个操作的摊还代价为ĉᵢ
- 对于任意n，要求：∑(i=1 to n) ĉᵢ ≥ ∑(i=1 to n) cᵢ

## 🔍 4. 经典示例详解

### 4.1 栈操作

考虑一个支持以下操作的栈：
- **PUSH(S, x)**：将元素x压入栈顶，实际代价为1
- **POP(S)**：弹出栈顶元素，实际代价为1
- **MULTIPOP(S, k)**：弹出栈顶k个元素（或栈中所有元素），实际代价为min(s, k)

#### 4.1.1 核算法分析

我们为每个操作分配如下摊还代价：
- PUSH：摊还代价2（1用于实际压入，1作为信用存储在该元素上）
- POP：摊还代价0（使用该元素上的信用支付实际代价）
- MULTIPOP：摊还代价0（使用被弹出元素上的信用支付实际代价）

#### 4.1.2 信用不变式

在任何时刻，栈中每个元素上都存储有1个信用单位，因此总信用等于栈中元素个数。

#### 4.1.3 正确性证明

由于总信用始终非负，且每个操作的摊还代价都是常数，因此：
- n个操作的总摊还代价为O(n)
- 总摊还代价是总实际代价的上界
- 每个操作的摊还代价为O(1)

### 4.2 二进制计数器自增

考虑一个k位二进制计数器，初始值为0。支持INCREMENT操作。

#### 4.2.1 核算法分析

我们为每次INCREMENT操作分配摊还代价2：
- 1用于将某位从0翻转为1的实际代价
- 1作为信用存储在该位上

当需要将某位从1翻转为0时，使用该位上存储的信用支付实际代价。

#### 4.2.2 信用不变式

在任何时刻，计数器中每个值为1的位上都存储有1个信用单位。

#### 4.2.3 正确性证明

由于总信用始终非负，且每次INCREMENT操作的摊还代价为2，因此：
- n次INCREMENT操作的总摊还代价为2n
- 总摊还代价是总实际代价的上界
- 每次INCREMENT操作的摊还代价为O(1)

### 4.3 动态数组扩容

考虑一个动态数组，当数组满时将其容量扩大一倍。

#### 4.3.1 核算法分析

我们为每次PUSH操作分配摊还代价3：
- 1用于插入元素的实际代价
- 2作为信用存储起来，用于未来的扩容操作

当需要扩容时，数组大小加倍，需要复制所有现有元素。这时使用之前存储的信用支付复制代价。

#### 4.3.2 信用不变式

在任何时刻，我们为数组中每个元素存储了至少2个信用单位，用于支付将来可能的复制代价。

#### 4.3.3 正确性证明

考虑第i次扩容，此时数组大小为2ⁱ：
- 需要复制2ⁱ个元素，代价为2ⁱ
- 这些元素是在之前的2ⁱ次插入操作中插入的
- 每次插入操作存储了2个信用单位，总共存储了2×2ⁱ = 2^(i+1)个信用单位
- 由于2^(i+1) ≥ 2ⁱ，因此有足够的信用支付扩容代价

因此：
- n次PUSH操作的总摊还代价为3n
- 每次PUSH操作的摊还代价为O(1)

## 💻 5. C++ 实现详解

### 5.1 栈操作实现

```cpp
class StackWithAccounting {
private:
    std::stack<int> data;
    int totalCredit;  // 总信用

public:
    void push(int value) {
        data.push(value);
        totalCredit += 1;  // 存储1个信用单位在该元素上
    }

    void pop() {
        if (!data.empty()) {
            data.pop();
            totalCredit -= 1;  // 使用1个信用单位支付实际代价
        }
    }

    void multipop(int k) {
        int popCount = std::min(k, (int)data.size());
        for (int i = 0; i < popCount; i++) {
            data.pop();
        }
        totalCredit -= popCount;  // 使用popCount个信用单位支付实际代价
    }
};
```

### 5.2 二进制计数器实现

```cpp
class BinaryCounterWithAccounting {
private:
    std::vector<bool> bits;
    int totalCredit;  // 总信用

public:
    void increment() {
        int i = 0;
        
        // 翻转所有连续的1位为0（使用这些位上的信用支付）
        while (i < bits.size() && bits[i] == true) {
            bits[i] = false;
            totalCredit -= 1;  // 使用1个信用单位支付翻转代价
            i++;
        }
        
        // 如果还有剩余位，将第一个0位翻转为1
        if (i < bits.size()) {
            bits[i] = true;
            totalCredit += 1;  // 存储1个信用单位在该位上
        }
    }
};
```

### 5.3 动态数组实现

```cpp
class DynamicArrayWithAccounting {
private:
    std::vector<int> data;
    int capacity;
    int totalCredit;  // 总信用

public:
    void push(int value) {
        // 检查是否需要扩容
        if (data.size() == capacity) {
            int oldCapacity = capacity;
            capacity *= 2;  // 扩容为原来的2倍
            
            // 使用之前存储的信用支付复制代价
            totalCredit -= data.size();
        }
        
        data.push_back(value);
        totalCredit += 2;  // 存储2个信用单位用于未来的扩容
    }
};
```

## 📊 6. 算法分析

### 6.1 时间复杂度

| 操作 | 实际代价 | 摊还代价 |
|------|----------|----------|
| 栈 PUSH | 1 | 2 |
| 栈 POP | 1 | 0 |
| 栈 MULTIPOP | min(s,k) | 0 |
| 计数器 INCREMENT | 实际翻转位数 | 2 |
| 动态数组 PUSH | 1或1+复制代价 | 3 |

### 6.2 空间复杂度

核算法不改变数据结构的空间复杂度，只是增加了对信用的跟踪。

## 🎯 7. 关键要点总结

✅ **核算法核心思想**：
- 为不同操作分配不同的摊还代价
- 高于实际代价的部分作为信用存储
- 低于实际代价的部分使用信用支付

✅ **信用管理原则**：
- 总信用必须始终保持非负
- 摊还代价必须是实际代价的上界

✅ **核算法优势**：
- 直观性强，像真实的记账过程
- 可以为不同操作分配不同的摊还代价
- 有助于理解每个操作对数据结构状态的影响

✅ **核算法挑战**：
- 需要精心设计信用不变式
- 需要证明摊还代价确实是实际代价的上界

## 🧪 8. 运行示例

当你运行提供的 C++ 代码时，你会看到类似以下的输出：

```
🧮 示例1: 栈操作 (包括MULTIPOP)
----------------------------------------
执行 PUSH(1)
  实际代价: 1 (压入元素)
  摊还代价: 2 (1用于实际操作，1作为信用存储在该元素上)
  当前栈内容: 1 
  当前信用总额: 1
执行 PUSH(2)
  实际代价: 1 (压入元素)
  摊还代价: 2 (1用于实际操作，1作为信用存储在该元素上)
  当前栈内容: 1 2 
  当前信用总额: 2
执行 POP - 弹出元素: 2
  实际代价: 1 (弹出元素)
  摊还代价: 0 (使用该元素上的信用支付实际代价)
  当前栈内容: 1 
  当前信用总额: 1

栈操作统计:
  总操作数: 9
  总实际代价: 12
  总摊还代价: 12
  总信用余额: 2
  平均实际代价: 1.33333
  平均摊还代价: 1.33333
```

## 📚 9. 延伸思考

1. **与其他摊还分析方法的关系**：
   - 核算法与势能法在数学上是等价的
   - 核算法更直观，势能法更形式化

2. **实际应用**：
   - Java Vector和ArrayList的扩容策略
   - 动态哈希表的扩容和收缩
   - 内存管理中的页分配

3. **扩展问题**：
   - 如果动态数组扩容因子不是2而是其他值，信用分配会如何变化？
   - 如何设计更复杂的信用不变式来分析其他数据结构？

---

💡 **学习建议**:
通过亲手实现和调试代码，你可以更深入地理解核算法的核心思想。重点关注信用如何在不同操作间流动，以及如何设计合适的信用不变式。尝试修改示例参数，观察不同操作序列对信用余额的影响，这对你掌握核算法很有帮助。