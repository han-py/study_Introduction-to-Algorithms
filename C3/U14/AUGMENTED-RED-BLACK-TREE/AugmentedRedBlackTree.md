# 数据结构的扩张 (Augmenting Data Structures)

## 简介

《算法导论》第十四章介绍了"数据结构的扩张"这一重要概念。数据结构的扩张是指在标准数据结构的基础上添加额外信息，以支持新的操作或提高某些操作的效率。这种方法允许我们在不完全重新设计数据结构的情况下，扩展其功能以适应特定应用需求。

本章主要关注如何扩张红黑树来支持动态集合上的顺序统计操作，并介绍了扩张数据结构的一般方法。

## 数据结构扩张的方法

扩张数据结构的过程可以概括为以下四个步骤：

1. **选择基础数据结构**：选择一个适合的基础数据结构作为扩张的起点。
2. **确定附加信息**：决定要在基础数据结构中维护哪些附加信息。
3. **验证维护能力**：检验基础数据结构上的基本修改操作（如插入、删除）能否维护附加信息。
4. **设计新操作**：开发能够利用附加信息的新操作。

## 动态顺序统计

动态顺序统计是数据结构扩张的一个重要应用。它使我们能够在动态集合上高效地执行以下操作：

1. **SELECT(k)**：返回集合中按排序顺序排列的第k小元素。
2. **RANK(x)**：返回元素x在集合线性序中的位置（秩）。

### 扩张红黑树实现顺序统计

为了支持动态顺序统计操作，我们在红黑树的每个节点中添加一个额外的字段`size`，表示以该节点为根的子树中的节点总数（包括该节点本身）。

#### 节点结构

```cpp
struct Node {
    int data;           // 节点存储的数据
    Color color;        // 节点颜色（红或黑）
    int size;           // 以该节点为根的子树的节点数量
    Node *left, *right, *parent;  // 左、右子节点和父节点指针
};
```

#### 维护size属性

在每次修改树结构的操作（如插入、删除、旋转）之后，我们需要更新受影响节点的size属性。更新公式为：

```
x.size = 1 + x.left.size + x.right.size
```

其中，空节点的size值为0。

#### SELECT操作

SELECT(k)操作返回树中第k小的元素：

1. 从根节点开始，计算左子树的节点数`leftSize`
2. 如果`k == leftSize + 1`，则当前节点就是第k小的元素
3. 如果`k <= leftSize`，则第k小的元素在左子树中
4. 如果`k > leftSize + 1`，则第k小的元素在右子树中，需要在右子树中查找第`(k - leftSize - 1)`小的元素

时间复杂度：O(log n)

#### RANK操作

RANK(x)操作返回节点x的秩（即在有序序列中的位置）：

1. 从节点x开始，沿着从x到根的路径向上移动
2. 当向上移动到父节点y时：
   - 如果x是y的左子节点，则不增加秩
   - 如果x是y的右子节点，则将`y.left.size + 1`加到秩上

时间复杂度：O(log n)

## 区间树简介

区间树是另一种重要的数据结构扩张应用，用于维护由区间构成的动态集合。每个节点存储一个区间，并支持快速查找与给定区间重叠的区间。

区间树的核心思想是：
1. 以区间的低位端点作为二叉搜索树的键值组织节点
2. 在每个节点x处存储以x为根的子树中所有区间的最大高位端点值`max`

## 扩张红黑树的定理

对于红黑树的扩张，有一个重要定理：

**定理14.1**：给定红黑树T的n个节点扩张，假设对于任意节点x，扩张的属性f能够仅依据x、x.left和x.right的信息（可能包含x.left.f和x.right.f）在O(1)时间内计算出x.f的值。那么我们可以在插入和删除操作期间维护T中所有节点的f值，且不会影响插入和删除操作O(log n)的渐近时间复杂度。

这个定理为扩张红黑树提供了理论保证，使得我们能够安全地添加各种辅助信息而不影响红黑树的基本性能。

## 示例程序解析

我们的示例程序实现了支持动态顺序统计的扩张红黑树，包含以下关键组件：

1. **节点结构**：在基础红黑树节点基础上添加了`size`字段
2. **size维护机制**：在每次树结构调整后更新相关节点的size值
3. **SELECT操作**：查找第k小元素的实现
4. **RANK操作**：计算元素在排序序列中位置的实现
5. **基础操作**：包括插入、旋转、遍历等红黑树基本操作

在主函数中，我们插入了测试数据[10, 20, 30, 15, 25, 5, 1]，然后演示了以下功能：
- 中序遍历和层序遍历，显示每个节点的值、颜色和子树大小
- SELECT操作，获取第1、3、5、7小的元素
- RANK操作，获取元素1、10、15、30的秩
- 基本的搜索操作

## 复杂度分析

| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 搜索 | O(log n)   | O(1)       |
| 插入 | O(log n)   | O(1)       |
| 删除 | O(log n)   | O(1)       |
| SELECT | O(log n) | O(1)       |
| RANK | O(log n)   | O(1)       |
| 遍历 | O(n)       | O(n)       |

其中n是树中节点的数量。

## 应用场景

1. **数据库系统**：用于实现高效的排名查询和分页功能
2. **操作系统**：用于进程调度中的优先级管理
3. **统计分析**：快速计算数据集中元素的百分位数
4. **在线算法**：在不知道未来数据的情况下维护统计数据
5. **游戏开发**：排行榜系统的实现

## 总结

数据结构的扩张是一个强大而实用的技术，它允许我们在现有数据结构的基础上添加新的功能，同时保持原有操作的效率。通过合理地设计附加信息和维护机制，我们可以显著扩展数据结构的功能。

本章介绍的动态顺序统计只是数据结构扩张的一个应用实例。类似的方法还可以应用于其他场景，如区间树、范围查询等。掌握这种技术对于设计和实现高效的算法和数据结构具有重要意义。

通过本示例程序，你可以清楚地看到如何通过添加size字段来扩张红黑树以支持顺序统计操作，以及如何在各种操作中正确维护这一附加信息。建议你修改主函数中的测试数据，亲自观察不同操作的效果，加深对数据结构扩张技术的理解。