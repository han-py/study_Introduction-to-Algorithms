# 插入排序 (Insertion Sort)

## 1. 算法简介

插入排序（Insertion Sort）是一种简单直观的排序算法，其工作原理类似于人们整理扑克牌的方式。它通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

## 2. 算法思想

插入排序的基本思想是：

1. 将数组分为已排序和未排序两部分；初始时，已排序部分只有一个元素（第一个元素）。
2. 依次将未排序部分的元素插入到已排序部分的正确位置。
3. 每插入一个元素，已排序部分就增加一个元素，未排序部分就减少一个元素。
4. 重复这个过程，直到所有元素都插入到正确的位置。

具体来说，插入排序会从数组的第二个元素开始，逐步与前面的元素进行比较，并将其插入到合适的位置，直到整个数组都排序完成。

## 3. 算法步骤

一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

## 4. 算法图解示例

以数组 [5, 3, 4, 1, 2] 为例：

| 步骤 | 已排序区间 | 当前元素 | 排序结果 |
|------|------------|----------|----------|
| 初始 | [5] | - | [5] |
| 第1步 | [5] | 3 | [3, 5] |
| 第2步 | [3, 5] | 4 | [3, 4, 5] |
| 第3步 | [3, 4, 5] | 1 | [1, 3, 4, 5] |
| 第4步 | [1, 3, 4, 5] | 2 | [1, 2, 3, 4, 5] |

## 5. 伪代码实现

```
INSERTION-SORT(A)
for j = 2 to A.length
    key = A[j]
    // Insert A[j] into the sorted sequence A[1..j-1]
    i = j - 1
    while i > 0 and A[i] > key
        A[i + 1] = A[i]
        i = i - 1
    A[i + 1] = key
```

## 6. C++代码实现

```cpp
#include <iostream>
#include <vector>

void insertionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        
        // 将大于key的元素向后移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

// 打印数组
void printArray(const std::vector<int>& arr) {
    for (int i = 0; i < arr.size(); i++) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

// 测试示例
int main() {
    std::vector<int> arr = {5, 2, 4, 6, 1, 3};
    std::cout << "排序前: ";
    printArray(arr);
    
    insertionSort(arr);
    
    std::cout << "排序后: ";
    printArray(arr);
    
    return 0;
}
```

## 7. 算法分析

### 时间复杂度

- **最好情况**：数组已经有序，时间复杂度为 O(n)
  - 此时内层循环不需要执行，只需要进行 n-1 次比较
  
- **最坏情况**：数组完全逆序，时间复杂度为 O(n²)
  - 此时需要进行 n(n-1)/2 次比较和移动操作
  
- **平均情况**：时间复杂度为 O(n²)
  - 平均情况下，每个元素需要与已排序序列中一半的元素进行比较

### 空间复杂度

- 插入排序是原地排序算法，空间复杂度为 O(1)
- 只需要常数级别的额外空间存储临时变量

### 稳定性

- 插入排序是一种稳定的排序算法
- 相等元素的相对位置在排序后不会改变

## 8. 算法特点

### 优点

1. 实现简单，代码简洁
2. 对于小规模数据排序效率较高
3. 是稳定排序算法
4. 是原地排序算法（空间复杂度为 O(1)）
5. 是自适应的排序算法，对于已经基本有序的数据效率很高
6. 是在线排序算法，可以在接收数据的过程中进行排序

### 缺点

1. 对于大规模数据排序效率较低，时间复杂度为 O(n²)
2. 每次只能移动相邻的元素，交换次数较多

## 9. 适用场景

1. **小规模数据集**：当数据量较小时，插入排序的简单性使其成为优选
2. **基本有序的数据集**：对于已经基本有序的数据，插入排序效率很高
3. **作为其他高级排序算法的子程序**：许多高级排序算法（如快速排序、归并排序）在处理小规模数据时会使用插入排序
4. **在线排序**：当数据是逐步接收时，插入排序可以边接收边排序

## 10. 与其他排序算法的比较

| 排序算法 | 最好时间复杂度 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 |
|---------|---------------|---------------|---------------|-----------|--------|
| 插入排序 | O(n) | O(n²) | O(n²) | O(1) | 稳定 |
| 冒泡排序 | O(n) | O(n²) | O(n²) | O(1) | 稳定 |
| 选择排序 | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 |
| 快速排序 | O(n log n) | O(n log n) | O(n²) | O(log n) | 不稳定 |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | 稳定 |

## 11. 优化方案

虽然插入排序本身效率不高，但可以通过以下方式进行优化：

1. **二分插入排序**：在查找插入位置时使用二分查找，减少比较次数
2. **希尔排序**：作为插入排序的改进版本，通过设定间隔进行分组插入排序

## 12. 总结

插入排序作为一种基础的排序算法，虽然在大规模数据排序方面效率不高，但由于其简单性和对小规模数据的良好性能，仍然具有重要的应用价值。它是许多高级排序算法的基础，在实际开发中经常被用作混合排序算法的一部分。