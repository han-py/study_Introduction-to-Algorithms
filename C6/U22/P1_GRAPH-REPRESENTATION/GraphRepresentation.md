# 图的表示方法 (Graph Representation)

> 📘 _《算法导论》第22章22.1节学习指南_

## 🎯 1. 简介

**图**(Graph)是计算机科学中一种重要的数据结构，用于表示对象之间的关系。图由**顶点**(Vertex)和**边**(Edge)组成，其中顶点表示对象，边表示对象之间的关系。

### 1.1 图的基本概念

图G由两个集合组成：顶点集V和边集E，表示为G=(V,E)。

- **顶点**(Vertex)：图中的基本单元，也称为节点(Node)
- **边**(Edge)：连接两个顶点的线段，表示顶点之间的关系
- **有向图**(Directed Graph)：边有方向性，从一个顶点指向另一个顶点
- **无向图**(Undirected Graph)：边没有方向性，连接两个顶点
- **权重图**(Weighted Graph)：边有权重或成本值

### 1.2 图的表示意义

图的表示方法决定了图算法的效率和实现复杂度。选择合适的图表示方法对于优化算法性能至关重要。

## 📚 2. 图的表示方法

图有两种主要的表示方法：

### 2.1 邻接表表示法 (Adjacency-List Representation)

邻接表表示法是图的一种常用表示方法，特别适用于稀疏图（边数远小于顶点数平方的图）。

#### 2.1.1 表示原理

对于图G=(V,E)，邻接表表示由一个包含|V|条链表的数组组成，每个链表对应一个顶点。对于每个顶点u∈V，邻接表Adj[u]包含所有与u相邻的顶点。

#### 2.1.2 示例图解

考虑一个有向图，顶点集V={0,1,2,3,4,5}，边集E={(0,1),(0,4),(1,2),(1,3),(2,4),(3,2),(3,5),(4,3),(5,5)}：

```
邻接表表示:
0: 1 → 4
1: 2 → 3
2: 4
3: 2 → 5
4: 3
5: 5
```

图形化表示：
```
    0 ──→ 1 ──→ 2 ──→ 4 ──→ 3 ──→ 5
    │     │     ↑     ↑     ↓     │
    │     └─────┼─────┼─────┼─────┘
    └───────────┼─────┼─────┘
                │     │
                └─────┘
```

### 2.2 邻接矩阵表示法 (Adjacency-Matrix Representation)

邻接矩阵表示法使用一个|V|×|V|的矩阵来表示图。

#### 2.2.1 表示原理

对于图G=(V,E)，邻接矩阵表示是一个|V|×|V|的矩阵A=(aᵢⱼ)，满足：

```
aᵢⱼ = { 1, 如果(i,j)∈E
      { 0, 如果(i,j)∉E
```

#### 2.2.2 示例图解

对于上面提到的图，邻接矩阵表示为：

```
    0 1 2 3 4 5
  ┌─────────────
0 │ 0 1 0 0 1 0
1 │ 0 0 1 1 0 0
2 │ 0 0 0 0 1 0
3 │ 0 0 1 0 0 1
4 │ 0 0 0 1 0 0
5 │ 0 0 0 0 0 1
```

## 🔧 3. 两种表示方法的比较

### 3.1 存储空间需求

| 表示方法 | 空间复杂度 | 适用场景 |
|---------|-----------|---------|
| 邻接表 | O(V+E) | 稀疏图 |
| 邻接矩阵 | O(V²) | 稠密图 |

### 3.2 时间复杂度比较

| 操作 | 邻接表 | 邻接矩阵 |
|-----|-------|---------|
| 测试边(u,v)是否存在 | O(out-degree(u)) | O(1) |
| 查找顶点u的所有邻居 | O(out-degree(u)) | O(V) |
| 添加边 | O(1) | O(1) |
| 删除边 | O(out-degree(u)) | O(1) |

### 3.3 选择原则

1. **稀疏图**（边数远小于V²）：推荐使用邻接表
2. **稠密图**（边数接近V²）：推荐使用邻接矩阵
3. **需要频繁测试边的存在性**：推荐使用邻接矩阵
4. **需要遍历顶点的所有邻居**：两种方法都可以，邻接表稍好

## 🧪 4. 实现详解

### 4.1 邻接表实现

```cpp
class AdjacencyListGraph {
private:
    int vertices;                           // 顶点数
    std::vector<std::list<int>> adjList;    // 邻接表
    
public:
    explicit AdjacencyListGraph(int v) : vertices(v), adjList(v) {}
    
    void addEdge(int u, int v) {
        adjList[u].push_back(v);
    }
};
```

#### 4.1.1 优点

1. **节省空间**：只需要O(V+E)的空间
2. **高效遍历**：可以在线性时间内遍历顶点的所有邻居
3. **灵活性**：容易添加和删除边

#### 4.1.2 缺点

1. **边查询慢**：测试边(u,v)是否存在需要O(out-degree(u))时间
2. **实现复杂**：相比邻接矩阵稍微复杂一些

### 4.2 邻接矩阵实现

```cpp
class AdjacencyMatrixGraph {
private:
    int vertices;                    // 顶点数
    std::vector<std::vector<int>> adjMatrix;  // 邻接矩阵
    
public:
    explicit AdjacencyMatrixGraph(int v) : vertices(v), adjMatrix(v, std::vector<int>(v, 0)) {}
    
    void addEdge(int u, int v) {
        adjMatrix[u][v] = 1;
    }
};
```

#### 4.2.1 优点

1. **快速查询**：测试边(u,v)是否存在只需O(1)时间
2. **实现简单**：逻辑清晰，易于理解和实现
3. **支持矩阵运算**：可以使用线性代数方法处理图问题

#### 4.2.2 缺点

1. **空间消耗大**：无论图是否稀疏都需要O(V²)空间
2. **遍历效率低**：遍历顶点u的所有邻居需要O(V)时间

## 📊 5. 实际应用示例

### 5.1 社交网络

在社交网络中，用户是顶点，好友关系是边：

- **邻接表表示**：适合表示用户的好友列表
- **邻接矩阵表示**：适合快速判断两人是否为好友

### 5.2 网络路由

在网络路由中，路由器是顶点，连接线路是边：

- **邻接表表示**：适合表示路由器的接口和连接
- **邻接矩阵表示**：适合计算最短路径

### 5.3 任务调度

在任务调度中，任务是顶点，依赖关系是边：

- **邻接表表示**：适合表示任务的前置依赖
- **邻接矩阵表示**：适合检测循环依赖

## 🎯 6. 图的遍历算法

### 6.1 广度优先搜索 (BFS)

广度优先搜索从起始顶点开始，逐层访问所有可达的顶点：

```cpp
void BFS(const AdjacencyListGraph& graph, int start) {
    std::vector<bool> visited(vertices, false);
    std::queue<int> queue;
    
    visited[start] = true;
    queue.push(start);
    
    while (!queue.empty()) {
        int current = queue.front();
        queue.pop();
        
        // 访问当前顶点的所有未访问过的邻居
        for (int neighbor : graph.getAdjacent(current)) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                queue.push(neighbor);
            }
        }
    }
}
```

#### 6.1.1 特点

- **时间复杂度**：O(V+E)
- **空间复杂度**：O(V)
- **应用**：最短路径查找、连通性检测

### 6.2 深度优先搜索 (DFS)

深度优先搜索从起始顶点开始，沿着一条路径尽可能深地访问顶点：

```cpp
void DFSUtil(const AdjacencyListGraph& graph, int vertex, std::vector<bool>& visited) {
    visited[vertex] = true;
    
    // 递归访问所有未访问过的邻居
    for (int neighbor : graph.getAdjacent(vertex)) {
        if (!visited[neighbor]) {
            DFSUtil(graph, neighbor, visited);
        }
    }
}

void DFS(const AdjacencyListGraph& graph, int start) {
    std::vector<bool> visited(vertices, false);
    DFSUtil(graph, start, visited);
}
```

#### 6.2.1 特点

- **时间复杂度**：O(V+E)
- **空间复杂度**：O(V)
- **应用**：拓扑排序、强连通分量检测

## 📈 7. 性能分析

### 7.1 稀疏图 vs 稠密图

| 类型 | 边数 | 推荐表示方法 |
|-----|-----|------------|
| 稀疏图 | E << V² | 邻接表 |
| 稠密图 | E ≈ V² | 邻接矩阵 |

### 7.2 操作性能对比

| 操作 | 邻接表 | 邻接矩阵 |
|-----|-------|---------|
| 存储空间 | O(V+E) | O(V²) |
| 添加顶点 | O(1) | O(V²) |
| 添加边 | O(1) | O(1) |
| 删除边 | O(V) | O(1) |
| 查询边 | O(V) | O(1) |
| 遍历邻居 | O(degree) | O(V) |

## 💡 8. 优化策略

### 8.1 邻接表优化

1. **使用哈希表代替链表**：可以将边查询时间从O(V)降到平均O(1)
2. **预分配内存**：避免频繁的内存分配和释放
3. **压缩存储**：对于特殊类型的图可以使用压缩技术

### 8.2 邻接矩阵优化

1. **位向量压缩**：使用位向量而非整数数组，节省空间
2. **稀疏矩阵技术**：对于稀疏图使用稀疏矩阵存储
3. **缓存优化**：优化内存布局以提高缓存命中率

## ⚠️ 9. 实现注意事项

### 9.1 内存管理

1. **邻接表**：注意链表节点的内存分配和释放
2. **邻接矩阵**：注意大矩阵可能导致的内存不足问题

### 9.2 边界条件

1. **空图**：正确处理没有顶点或边的图
2. **自环**：正确处理顶点到自身的边
3. **多重边**：决定是否允许多条相同的边

### 9.3 数据类型选择

1. **顶点标识**：可以使用整数、字符串或其他类型
2. **边权重**：可以使用整数、浮点数或其他数值类型
3. **布尔值**：可以用bool或整数0/1表示边的存在性

## 🧠 10. 总结

图的表示是图论算法的基础，选择合适的表示方法对算法性能有重要影响。

### 10.1 核心要点

1. **邻接表适用于稀疏图**：节省空间，遍历邻居效率高
2. **邻接矩阵适用于稠密图**：查询边快，实现简单
3. **根据应用需求选择**：考虑主要操作类型和性能要求

### 10.2 学习建议

1. **理解基本概念**：掌握图的基本术语和性质
2. **动手实现**：通过编码加深对两种表示方法的理解
3. **性能测试**：在不同规模的图上测试两种方法的性能
4. **实际应用**：尝试将图表示方法应用到实际问题中

### 10.3 进一步学习

1. **加权图表示**：学习如何表示带权重的图
2. **特殊图类**：研究树、二分图等特殊图类的表示方法
3. **动态图**：学习支持动态添加/删除顶点和边的图表示
4. **并行图算法**：研究适合并行计算的图表示方法

通过我们的示例代码和详细文档，您可以清楚地了解图的两种主要表示方法及其各自的优缺点。这为进一步学习图算法奠定了坚实的基础。