# 图的表示方法 (Graph Representation)

> 📘 _《算法导论》第22章22.1节学习指南_

## 🎯 1. 简介

**图**(Graph)是计算机科学中一种重要的数据结构，用于表示对象之间的关系。图由**顶点**(Vertex)和**边**(Edge)组成，其中顶点表示对象，边表示对象之间的关系。

### 1.1 图的基本概念

图G由两个集合组成：顶点集V和边集E，表示为G=(V,E)。

- **顶点**(Vertex)：图中的基本单元，也称为节点(Node)
- **边**(Edge)：连接两个顶点的线段，表示顶点之间的关系
- **有向图**(Directed Graph)：边有方向性，从一个顶点指向另一个顶点
- **无向图**(Undirected Graph)：边没有方向性，连接两个顶点
- **权重图**(Weighted Graph)：边有权重或成本值

### 1.2 图的实际应用

图在现实世界中有广泛的应用：

1. **社交网络**：用户是顶点，好友关系是边
2. **互联网**：网页是顶点，超链接是边
3. **交通网络**：城市是顶点，道路是边
4. **电路设计**：电子元件是顶点，连线是边
5. **任务调度**：任务是顶点，依赖关系是边

### 1.3 图的表示意义

图的表示方法决定了图算法的效率和实现复杂度。选择合适的图表示方法对于优化算法性能至关重要。

## 📚 2. 图的表示方法

图有两种主要的表示方法：

### 2.1 邻接表表示法 (Adjacency-List Representation)

邻接表表示法是图的一种常用表示方法，特别适用于稀疏图（边数远小于顶点数平方的图）。

#### 2.1.1 表示原理

对于图G=(V,E)，邻接表表示由一个包含|V|条链表的数组组成，每个链表对应一个顶点。对于每个顶点u∈V，邻接表Adj[u]包含所有与u相邻的顶点。

在有向图中，如果边(u,v)∈E，则顶点v出现在顶点u的邻接表中。

在无向图中，如果边(u,v)∈E，则顶点v出现在顶点u的邻接表中，同时顶点u也出现在顶点v的邻接表中。

#### 2.1.2 示例图解

考虑一个有向图，顶点集V={0,1,2,3,4,5}，边集E={(0,1),(0,4),(1,2),(1,3),(2,4),(3,2),(3,5),(4,3),(5,5)}：

```
邻接表表示:
0: 1 → 4
1: 2 → 3
2: 4
3: 2 → 5
4: 3
5: 5
```

图形化表示：
```
    0 ──→ 1 ──→ 2 ──→ 4 ──→ 3 ──→ 5
    │     │     ↑     ↑     ↓     │
    │     └─────┼─────┼─────┼─────┘
    └───────────┼─────┼─────┘
                │     │
                └─────┘
```

对于无向图，比如顶点集V={0,1,2,3}，边集E={(0,1),(0,2),(1,2),(2,3)}：

```
邻接表表示:
0: 1 → 2
1: 0 → 2
2: 0 → 1 → 3
3: 2
```

图形化表示：
```
    0 ── 1
    |\   |
    | \  |
    |  \ |
    2 ── 3
```

#### 2.1.3 数学表达

对于有向图G=(V,E)：
- 邻接表Adj[u] = {v ∈ V : (u,v) ∈ E}
- 所有邻接表的大小之和等于|E|

对于无向图G=(V,E)：
- 邻接表Adj[u] = {v ∈ V : (u,v) ∈ E}
- 所有邻接表的大小之和等于2|E|

### 2.2 邻接矩阵表示法 (Adjacency-Matrix Representation)

邻接矩阵表示法使用一个|V|×|V|的矩阵来表示图。

#### 2.2.1 表示原理

对于图G=(V,E)，邻接矩阵表示是一个|V|×|V|的矩阵A=(aᵢⱼ)，满足：

对于无向图：
```
aᵢⱼ = { 1, 如果(i,j)∈E
      { 0, 如果(i,j)∉E
```

对于有向图：
```
aᵢⱼ = { 1, 如果(i,j)∈E
      { 0, 如果(i,j)∉E
```

对于带权重的图：
```
aᵢⱼ = { w(i,j), 如果(i,j)∈E，w(i,j)是边(i,j)的权重
      { 0 或 ∞, 如果(i,j)∉E
```

#### 2.2.2 示例图解

对于上面提到的有向图，邻接矩阵表示为：

```
    0 1 2 3 4 5
  ┌─────────────
0 │ 0 1 0 0 1 0
1 │ 0 0 1 1 0 0
2 │ 0 0 0 0 1 0
3 │ 0 0 1 0 0 1
4 │ 0 0 0 1 0 0
5 │ 0 0 0 0 0 1
```

对于上面提到的无向图，邻接矩阵表示为（矩阵是对称的）：

```
    0 1 2 3
  ┌────────
0 │ 0 1 1 0
1 │ 1 0 1 0
2 │ 1 1 0 1
3 │ 0 0 1 0
```

#### 2.2.3 数学表达

对于图G=(V,E)：
- 邻接矩阵A是一个|V|×|V|的0-1矩阵
- 对于无向图，矩阵是对称的，即aᵢⱼ = aⱼᵢ
- 矩阵中第i行的1的个数等于顶点i的出度
- 矩阵中第j列的1的个数等于顶点j的入度

## 🔧 3. 两种表示方法的比较

### 3.1 存储空间需求

| 表示方法 | 空间复杂度 | 适用场景 |
|---------|-----------|---------|
| 邻接表 | O(V+E) | 稀疏图 |
| 邻接矩阵 | O(V²) | 稠密图 |

#### 3.1.1 邻接表空间分析

邻接表需要存储：
- V个链表头指针：O(V)
- E条边的节点：O(E)
- 总共：O(V+E)

#### 3.1.2 邻接矩阵空间分析

邻接矩阵需要存储：
- V×V个矩阵元素：O(V²)

### 3.2 时间复杂度比较

| 操作 | 邻接表 | 邻接矩阵 |
|-----|-------|---------|
| 测试边(u,v)是否存在 | O(out-degree(u)) | O(1) |
| 查找顶点u的所有邻居 | O(out-degree(u)) | O(V) |
| 添加边 | O(1) | O(1) |
| 删除边 | O(out-degree(u)) | O(1) |

### 3.3 选择原则

1. **稀疏图**（边数远小于V²）：推荐使用邻接表
2. **稠密图**（边数接近V²）：推荐使用邻接矩阵
3. **需要频繁测试边的存在性**：推荐使用邻接矩阵
4. **需要遍历顶点的所有邻居**：两种方法都可以，邻接表稍好

## 🧪 4. 实现详解

### 4.1 邻接表实现

```cpp
class AdjacencyListGraph {
private:
    int vertices;                           // 顶点数
    std::vector<std::list<int>> adjList;    // 邻接表
    
public:
    explicit AdjacencyListGraph(int v) : vertices(v), adjList(v) {}
    
    void addEdge(int u, int v) {
        adjList[u].push_back(v);
    }
};
```

#### 4.1.1 优点

1. **节省空间**：只需要O(V+E)的空间
2. **高效遍历**：可以在线性时间内遍历顶点的所有邻居
3. **灵活性**：容易添加和删除边
4. **自然表示**：符合图的直观表示

#### 4.1.2 缺点

1. **边查询慢**：测试边(u,v)是否存在需要O(out-degree(u))时间
2. **实现复杂**：相比邻接矩阵稍微复杂一些
3. **内存碎片**：链表可能导致内存碎片

#### 4.1.3 适用场景

- 社交网络：用户数很多，但每个用户的直接好友数相对较少
- 网页链接：网页数庞大，但每个页面的出链数量有限
- 任务依赖：任务数量多，但每个任务的直接依赖项不多

### 4.2 邻接矩阵实现

```cpp
class AdjacencyMatrixGraph {
private:
    int vertices;                    // 顶点数
    std::vector<std::vector<int>> adjMatrix;  // 邻接矩阵
    
public:
    explicit AdjacencyMatrixGraph(int v) : vertices(v), adjMatrix(v, std::vector<int>(v, 0)) {}
    
    void addEdge(int u, int v) {
        adjMatrix[u][v] = 1;
    }
};
```

#### 4.2.1 优点

1. **快速查询**：测试边(u,v)是否存在只需O(1)时间
2. **实现简单**：逻辑清晰，易于理解和实现
3. **支持矩阵运算**：可以使用线性代数方法处理图问题
4. **内存局部性好**：连续内存访问，缓存友好

#### 4.2.2 缺点

1. **空间消耗大**：无论图是否稀疏都需要O(V²)空间
2. **遍历效率低**：遍历顶点u的所有邻居需要O(V)时间
3. **不适合大图**：当顶点数很大时，内存需求可能超出限制

#### 4.2.3 适用场景

- 交通网络：城市间航班或铁路连接密集
- 电路设计：电子元件连接紧密
- 游戏AI：状态转移图较密集

## 📊 5. 实际应用示例

### 5.1 社交网络

在社交网络中，用户是顶点，好友关系是边：

- **邻接表表示**：适合表示用户的好友列表，因为大多数用户的直接好友数量远小于总用户数
- **邻接矩阵表示**：适合快速判断两人是否为好友，但当用户数很大时占用空间过多

### 5.2 网络路由

在网络路由中，路由器是顶点，连接线路是边：

- **邻接表表示**：适合表示路由器的接口和连接
- **邻接矩阵表示**：适合计算最短路径，特别是在密集连接的网络中

### 5.3 任务调度

在任务调度中，任务是顶点，依赖关系是边：

- **邻接表表示**：适合表示任务的前置依赖
- **邻接矩阵表示**：适合检测循环依赖

### 5.4 网页链接分析

在网页链接分析中，网页是顶点，超链接是边：

- **邻接表表示**：适合表示网页的出链
- **邻接矩阵表示**：PageRank算法可以直接使用矩阵运算

## 🎯 6. 图的遍历算法

### 6.1 广度优先搜索 (BFS)

广度优先搜索从起始顶点开始，逐层访问所有可达的顶点：

```cpp
void BFS(const AdjacencyListGraph& graph, int start) {
    std::vector<bool> visited(vertices, false);
    std::queue<int> queue;
    
    visited[start] = true;
    queue.push(start);
    
    while (!queue.empty()) {
        int current = queue.front();
        queue.pop();
        
        // 访问当前顶点的所有未访问过的邻居
        for (int neighbor : graph.getAdjacent(current)) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                queue.push(neighbor);
            }
        }
    }
}
```

#### 6.1.1 特点

- **时间复杂度**：O(V+E)
- **空间复杂度**：O(V)
- **应用**：最短路径查找、连通性检测

#### 6.1.2 工作原理

1. 从起始顶点开始，标记为已访问并加入队列
2. 当队列不为空时，取出队首顶点
3. 访问该顶点的所有未访问邻居，标记为已访问并加入队列
4. 重复步骤2-3直到队列为空

#### 6.1.3 算法步骤详解

1. **初始化阶段**：
   - 创建访问标记数组visited，全部初始化为false
   - 创建队列queue
   - 标记起始顶点为已访问，加入队列

2. **主循环阶段**：
   - 当队列不为空时：
     - 取出队首元素作为当前顶点
     - 遍历当前顶点的所有邻居
     - 对于每个未访问的邻居：
       - 标记为已访问
       - 加入队列

3. **终止条件**：
   - 队列为空时算法结束

### 6.2 深度优先搜索 (DFS)

深度优先搜索从起始顶点开始，沿着一条路径尽可能深地访问顶点：

```cpp
void DFSUtil(const AdjacencyListGraph& graph, int vertex, std::vector<bool>& visited) {
    visited[vertex] = true;
    
    // 递归访问所有未访问过的邻居
    for (int neighbor : graph.getAdjacent(vertex)) {
        if (!visited[neighbor]) {
            DFSUtil(graph, neighbor, visited);
        }
    }
}

void DFS(const AdjacencyListGraph& graph, int start) {
    std::vector<bool> visited(vertices, false);
    DFSUtil(graph, start, visited);
}
```

#### 6.2.1 特点

- **时间复杂度**：O(V+E)
- **空间复杂度**：O(V)
- **应用**：拓扑排序、强连通分量检测

#### 6.2.2 工作原理

1. 从起始顶点开始，标记为已访问
2. 递归访问所有未访问的邻居顶点
3. 当无法继续深入时，回溯到上一个顶点
4. 重复步骤2-3直到所有可达顶点都被访问

#### 6.2.3 算法步骤详解

1. **初始化阶段**：
   - 创建访问标记数组visited，全部初始化为false

2. **递归访问阶段**：
   - 对于当前顶点：
     - 标记为已访问
     - 对于每个未访问的邻居：
       - 递归访问该邻居

3. **回溯阶段**：
   - 当某顶点的所有邻居都已访问时，自动回溯到上一层调用

### 6.3 迭代版DFS

为了避免递归可能导致的栈溢出问题，可以使用迭代版本的DFS：

```cpp
void DFSIterative(const AdjacencyListGraph& graph, int start) {
    std::vector<bool> visited(vertices, false);
    std::stack<int> stack;
    
    stack.push(start);
    
    while (!stack.empty()) {
        int current = stack.top();
        stack.pop();
        
        if (!visited[current]) {
            visited[current] = true;
            
            // 将所有未访问的邻居压入栈中
            for (int neighbor : graph.getAdjacent(current)) {
                if (!visited[neighbor]) {
                    stack.push(neighbor);
                }
            }
        }
    }
}
```

## 📈 7. 性能分析

### 7.1 稀疏图 vs 稠密图

| 类型 | 边数 | 推荐表示方法 |
|-----|-----|------------|
| 稀疏图 | E << V² | 邻接表 |
| 稠密图 | E ≈ V² | 邻接矩阵 |

### 7.2 操作性能对比

| 操作 | 邻接表 | 邻接矩阵 |
|-----|-------|---------|
| 存储空间 | O(V+E) | O(V²) |
| 添加顶点 | O(1) | O(V²) |
| 添加边 | O(1) | O(1) |
| 删除边 | O(V) | O(1) |
| 查询边 | O(V) | O(1) |
| 遍历邻居 | O(degree) | O(V) |

### 7.3 复杂度分析详解

#### 7.3.1 邻接表复杂度分析

- **空间复杂度**：每个顶点需要一个链表头，每条边需要一个链表节点，总共O(V+E)
- **添加边**：只需在链表末尾添加一个节点，时间为O(1)
- **查询边**：需要遍历源顶点的邻接表，时间为O(out-degree(u))
- **遍历邻居**：需要遍历整个邻接表，时间为O(out-degree(u))

#### 7.3.2 邻接矩阵复杂度分析

- **空间复杂度**：需要V×V的矩阵，空间为O(V²)
- **添加边**：只需设置矩阵中的一个元素，时间为O(1)
- **查询边**：直接访问矩阵元素，时间为O(1)
- **遍历邻居**：需要检查一行中的所有V个元素，时间为O(V)

### 7.4 实际性能考量

在实际应用中，还需考虑以下因素：

1. **缓存效应**：邻接矩阵具有更好的内存局部性
2. **实现复杂度**：邻接表实现略复杂
3. **动态性**：邻接表更适合动态添加/删除顶点
4. **算法需求**：某些算法更适合某种表示方法

## 💡 8. 优化策略

### 8.1 邻接表优化

1. **使用哈希表代替链表**：可以将边查询时间从O(V)降到平均O(1)
2. **预分配内存**：避免频繁的内存分配和释放
3. **压缩存储**：对于特殊类型的图可以使用压缩技术
4. **使用向量代替链表**：在某些情况下向量比链表有更好的缓存性能

### 8.2 邻接矩阵优化

1. **位向量压缩**：使用位向量而非整数数组，节省空间
2. **稀疏矩阵技术**：对于稀疏图使用稀疏矩阵存储
3. **缓存优化**：优化内存布局以提高缓存命中率
4. **使用三角矩阵**：对于无向图，可以只存储上三角或下三角部分

### 8.3 混合表示方法

在某些情况下，可以结合两种方法的优点：

1. **邻接表+邻接矩阵混合**：对热点顶点使用邻接矩阵，其他使用邻接表
2. **分层表示**：粗粒度使用邻接矩阵，细粒度使用邻接表

## ⚠️ 9. 实现注意事项

### 9.1 内存管理

1. **邻接表**：注意链表节点的内存分配和释放
2. **邻接矩阵**：注意大矩阵可能导致的内存不足问题
3. **动态图**：考虑顶点和边的动态添加和删除

### 9.2 边界条件

1. **空图**：正确处理没有顶点或边的图
2. **自环**：正确处理顶点到自身的边
3. **多重边**：决定是否允许多条相同的边
4. **孤立顶点**：处理没有边连接的顶点

### 9.3 数据类型选择

1. **顶点标识**：可以使用整数、字符串或其他类型
2. **边权重**：可以使用整数、浮点数或其他数值类型
3. **布尔值**：可以用bool或整数0/1表示边的存在性

### 9.4 错误处理

1. **越界检查**：验证顶点索引是否合法
2. **重复边**：处理重复添加同一条边的情况
3. **非法操作**：处理对不存在顶点的操作

## 🧠 10. 总结

图的表示是图论算法的基础，选择合适的表示方法对算法性能有重要影响。

### 10.1 核心要点

1. **邻接表适用于稀疏图**：节省空间，遍历邻居效率高
2. **邻接矩阵适用于稠密图**：查询边快，实现简单
3. **根据应用需求选择**：考虑主要操作类型和性能要求

### 10.2 学习建议

1. **理解基本概念**：掌握图的基本术语和性质
2. **动手实现**：通过编码加深对两种表示方法的理解
3. **性能测试**：在不同规模的图上测试两种方法的性能
4. **实际应用**：尝试将图表示方法应用到实际问题中

### 10.3 进一步学习

1. **加权图表示**：学习如何表示带权重的图
2. **特殊图类**：研究树、二分图等特殊图类的表示方法
3. **动态图**：学习支持动态添加/删除顶点和边的图表示
4. **并行图算法**：研究适合并行计算的图表示方法
5. **外部存储图**：研究处理无法完全载入内存的大图的方法

通过我们的示例代码和详细文档，您可以清楚地了解图的两种主要表示方法及其各自的优缺点。这为进一步学习图算法奠定了坚实的基础。