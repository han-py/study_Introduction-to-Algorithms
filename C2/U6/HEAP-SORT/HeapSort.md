# 堆排序 (Heap Sort)

## 1. 算法简介

堆排序（Heap Sort）是一种基于比较的排序算法，利用堆这种数据结构来实现排序。堆排序是选择排序的一种改进版本，它的最坏、最好和平均时间复杂度均为 O(n log n)，是一种相对高效的排序算法。

堆是一种特殊的完全二叉树结构，具有以下两个重要特性：
1. 堆是一个完全二叉树，除了最底层外，其他层的节点都是满的，最底层的节点从左到右填充。
2. 堆具有堆性质：
   - 在最大堆中，每个节点的值都大于或等于其子节点的值
   - 在最小堆中，每个节点的值都小于或等于其子节点的值

## 2. 算法思想

堆排序的核心思想是：
1. 将待排序的数组构造成一个最大堆（用于升序排列）或最小堆（用于降序排列）
2. 此时整个序列的最大值（或最小值）就是堆顶的根节点
3. 将堆顶元素与堆的最后一个元素进行交换，此时末尾元素就为最大值（或最小值）
4. 将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次大值（或次小值）
5. 如此反复执行，便能得到一个有序序列

## 3. 算法步骤

堆排序的具体实现过程分为两个主要阶段：

### 3.1 构建堆阶段
1. 将无序数组构建成一个二叉堆（以最大堆为例）
2. 从最后一个非叶子节点开始，从右至左、从下至上进行调整
3. 使得每个节点都满足堆的性质，最终得到一个初始的最大堆

### 3.2 排序阶段
1. 将堆顶元素（最大值）与堆的最后一个元素交换
2. 将堆的尺寸缩小 1
3. 调用调整函数（如 maxHeapify），将新的数组顶端数据调整到相应位置
4. 重复步骤 2-3，直到堆的尺寸为 1

## 4. 算法图解示例

以数组 [4, 1, 3, 2, 16, 9, 10, 14, 8, 7] 为例：

### 4.1 构建最大堆过程
```
初始数组: [4, 1, 3, 2, 16, 9, 10, 14, 8, 7]

构建堆过程:
           4(0)
         /      \
      1(1)      3(2)
     /    \     /    \
   2(3)  16(4) 9(5) 10(6)
  /  \   /
14(7) 8(8) 7(9)

经过调整后形成最大堆:
           16
         /    \
       14      10
      /  \    /  \
     8    4  9    3
    / \  / \
   7  2 1  16
```

### 4.2 排序过程
1. 将堆顶 16 与末尾元素 7 交换，数组变为 [7, 14, 10, 8, 4, 9, 3, 2, 1, 16]
2. 对前 9 个元素重新调整堆，得到新的最大堆
3. 将新的堆顶 14 与末尾元素 1 交换
4. 重复上述过程，直到整个数组有序

## 5. 伪代码实现

```
HEAPSORT(A)
1. BUILD-MAX-HEAP(A)
2. for i = A.length downto 2
3.     exchange A[1] with A[i]
4.     A.heap-size = A.heap-size - 1
5.     MAX-HEAPIFY(A, 1)

BUILD-MAX-HEAP(A)
1. A.heap-size = A.length
2. for i = ⌊A.length/2⌋ downto 1
3.     MAX-HEAPIFY(A, i)

MAX-HEAPIFY(A, i)
1. l = LEFT(i)
2. r = RIGHT(i)
3. if l ≤ A.heap-size and A[l] > A[i]
4.     largest = l
5. else largest = i
6. if r ≤ A.heap-size and A[r] > A[largest]
7.     largest = r
8. if largest ≠ i
9.     exchange A[i] with A[largest]
10.    MAX-HEAPIFY(A, largest)
```

## 6. C++代码实现

```cpp
#include <iostream>
#include <vector>

/**
 * 维护最大堆性质
 * @param arr 数组表示的堆
 * @param heapSize 堆的大小
 * @param i 需要维护节点的索引
 */
void maxHeapify(std::vector<int>& arr, int heapSize, int i) {
    int largest = i;          // 初始化最大值为根节点
    int left = 2 * i + 1;     // 左子节点
    int right = 2 * i + 2;    // 右子节点

    // 如果左子节点存在且大于根节点
    if (left < heapSize && arr[left] > arr[largest])
        largest = left;

    // 如果右子节点存在且大于当前最大值
    if (right < heapSize && arr[right] > arr[largest])
        largest = right;

    // 如果最大值不是根节点
    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        // 递归地调整受影响的子树
        maxHeapify(arr, heapSize, largest);
    }
}

/**
 * 构建最大堆
 * @param arr 待构建堆的数组
 * @param n 数组长度
 */
void buildMaxHeap(std::vector<int>& arr, int n) {
    // 从最后一个非叶子节点开始，自底向上构建最大堆
    for (int i = n / 2 - 1; i >= 0; i--)
        maxHeapify(arr, n, i);
}

/**
 * 堆排序算法实现
 * @param arr 待排序的数组
 */
void heapSort(std::vector<int>& arr) {
    int n = arr.size();

    // 构建最大堆
    buildMaxHeap(arr, n);

    // 逐个从堆顶取出元素
    for (int i = n - 1; i > 0; i--) {
        // 将当前最大元素（堆顶）移到数组末尾
        std::swap(arr[0], arr[i]);

        // 对剩下的元素重新调整为最大堆
        maxHeapify(arr, i, 0);
    }
}

/**
 * 打印数组元素
 * @param arr 要打印的数组
 */
void printArray(const std::vector<int>& arr) {
    for (size_t i = 0; i < arr.size(); i++) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

/**
 * 主函数，用于测试堆排序算法
 */
int main() {
    std::vector<int> arr = {4, 1, 3, 2, 16, 9, 10, 14, 8, 7};
    std::cout << "排序前: ";
    printArray(arr);
    
    heapSort(arr);
    
    std::cout << "排序后: ";
    printArray(arr);
    
    return 0;
}
```

## 7. 算法分析

### 7.1 时间复杂度

- **构建堆的时间复杂度**：O(n)
  - 虽然看起来是 O(n log n)，但通过更细致的分析可以证明实际上是 O(n)
  
- **排序阶段的时间复杂度**：O(n log n)
  - 需要执行 n-1 次循环
  - 每次循环中调用 maxHeapify 函数的时间复杂度为 O(log n)
  
- **总体时间复杂度**：O(n log n)
  - 无论最好、最坏还是平均情况，时间复杂度都是 O(n log n)

### 7.2 空间复杂度

- 堆排序是原地排序算法，空间复杂度为 O(1)
- 只需要常数级别的额外空间存储临时变量
- 递归调用 maxHeapify 函数的递归深度为 O(log n)

### 7.3 稳定性

- 堆排序是一种不稳定的排序算法
- 在排序过程中，相等元素的相对位置可能会发生变化

## 8. 算法特点

### 8.1 优点

1. **时间复杂度稳定**：无论什么情况，时间复杂度都是 O(n log n)
2. **空间复杂度低**：是原地排序算法，只需要 O(1) 的额外空间
3. **适应性强**：不受输入数据初始状态的影响
4. **适合大数据量**：相比 O(n²) 的排序算法，在处理大量数据时性能更好

### 8.2 缺点

1. **不稳定**：相等元素的相对位置可能发生改变
2. **常数因子较大**：虽然时间复杂度是 O(n log n)，但实际运行时间可能比快速排序慢
3. **缓存性能差**：堆排序的访问模式对缓存不友好
4. **不适合链表**：堆排序需要数组下标随机访问的特性

## 9. 适用场景

1. **对时间复杂度有严格要求的场景**：当需要保证最坏情况下仍是 O(n log n) 时间复杂度时
2. **内存受限的环境**：由于是原地排序，适用于内存有限的嵌入式系统
3. **大规模数据排序**：当数据量很大时，堆排序的性能优于 O(n²) 的排序算法
4. **优先队列实现**：堆数据结构本身就常用于实现优先队列

## 10. 与其他排序算法的比较

| 排序算法 | 最好时间复杂度 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 |
|---------|---------------|---------------|---------------|-----------|--------|
| 插入排序 | O(n) | O(n²) | O(n²) | O(1) | 稳定 |
| 冒泡排序 | O(n) | O(n²) | O(n²) | O(1) | 稳定 |
| 选择排序 | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 |
| 堆排序 | O(n log n) | O(n log n) | O(n log n) | O(1) | 不稳定 |
| 快速排序 | O(n log n) | O(n log n) | O(n²) | O(log n) | 不稳定 |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | 稳定 |

## 11. 优化方案

虽然堆排序本身的优化空间有限，但仍有一些改进方向：

1. **迭代版本的 heapify**：使用迭代代替递归，避免函数调用开销
2. **Floyd 建堆算法优化**：在某些特殊情况下可以进一步优化建堆过程
3. **与其他算法结合**：对于小数组使用插入排序，大数组使用堆排序

## 12. 总结

堆排序是一种高效的排序算法，具有稳定的时间复杂度和较低的空间复杂度。虽然它不是稳定排序，但在很多实际应用中仍然非常有用。特别是当需要保证最坏情况下的性能时，堆排序是一个很好的选择。

堆排序的核心在于理解和掌握堆这种数据结构以及相关的操作，包括建堆和维护堆性质。通过合理地利用堆的特性，我们可以实现高效的排序算法。

在实际应用中，堆排序常用于解决需要频繁获取最值元素的问题，比如优先队列的实现。掌握堆排序不仅有助于理解算法设计思想，也为后续学习更复杂的数据结构和算法打下了坚实的基础。