# 快速排序 (Quick Sort)

## 1. 算法简介

快速排序（Quick Sort）是由英国计算机科学家托尼·霍尔（C. A. R. Hoare）在1960年提出的一种高效的排序算法。它是对冒泡排序的一种改进，采用了分治法（Divide and Conquer）的思想。

快速排序通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。

快速排序在实际应用中性能非常出色，被认为是实践中最快的排序算法之一，也是《算法导论》中重点讲解的排序算法。

## 2. 算法思想

快速排序的核心思想是分治法：

1. **分解（Divide）**：在待排序的数组中选择一个元素作为基准（pivot），通过一趟排序将待排序数组分割成两个子数组，其中一个子数组的所有元素都小于基准元素，另一个子数组的所有元素都大于或等于基准元素。基准元素在这个过程中会到达其最终排序位置。

2. **解决（Conquer）**：递归地对两个子数组进行快速排序。

3. **合并（Combine）**：由于子数组都是原地排序的，当递归过程结束时，整个数组就已经有序，不需要额外的合并操作。

## 3. 算法步骤

快速排序的具体实现过程分为以下几个步骤：

### 3.1 分区操作（Partition）
1. 从数组中选择一个元素作为基准（pivot），通常选择最后一个元素
2. 重新排列数组，使得所有小于基准的元素都在基准前面，所有大于或等于基准的元素都在基准后面
3. 返回基准元素的最终位置

### 3.2 递归排序
1. 对基准左边的子数组递归执行快速排序
2. 对基准右边的子数组递归执行快速排序

## 4. 算法图解示例

以数组 [10, 7, 8, 9, 1, 5] 为例演示快速排序过程：

### 4.1 第一次分区
```
选择基准元素 5
原数组: [10, 7, 8, 9, 1, 5]

分区过程:
- 10 > 5，不动
- 7 > 5，不动
- 8 > 5，不动
- 9 > 5，不动
- 1 < 5，与第一个大于5的元素交换位置

交换后: [1, 7, 8, 9, 10, 5]
将基准5与第一个大于5的元素交换: [1, 5, 8, 9, 10, 7]

继续调整直到正确位置: [1, 5, 7, 8, 9, 10]
基准元素5的最终位置是索引1
```

### 4.2 递归处理子数组
1. 对左子数组 [1] 进行排序（只有一个元素，无需排序）
2. 对右子数组 [7, 8, 9, 10] 进行排序，选择基准8...

继续递归直到整个数组有序。

## 5. 伪代码实现

```
QUICKSORT(A, p, r)
1. if p < r
2.     q = PARTITION(A, p, r)
3.     QUICKSORT(A, p, q-1)
4.     QUICKSORT(A, q+1, r)

PARTITION(A, p, r)
1. x = A[r]  // 选择最后一个元素作为基准
2. i = p - 1
3. for j = p to r-1
4.     if A[j] ≤ x
5.         i = i + 1
6.         exchange A[i] with A[j]
7. exchange A[i+1] with A[r]
8. return i+1
```

## 6. C++代码实现

```cpp
#include <iostream>
#include <vector>

/**
 * 分区函数，快速排序的核心
 * @param arr 待排序数组
 * @param low 起始索引
 * @param high 结束索引
 * @return 分区点索引
 */
int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high];  // 选择最后一个元素作为基准
    int i = low - 1;  // 较小元素的索引

    for (int j = low; j <= high - 1; j++) {
        // 如果当前元素小于或等于基准
        if (arr[j] <= pivot) {
            i++;  // 较小元素索引增加
            std::swap(arr[i], arr[j]);
        }
    }
    std::swap(arr[i + 1], arr[high]);
    return (i + 1);
}

/**
 * 快速排序主函数
 * @param arr 待排序数组
 * @param low 起始索引
 * @param high 结束索引
 */
void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        // 获取分区索引
        int pi = partition(arr, low, high);

        // 分别对基准元素左右两部分进行排序
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

/**
 * 快速排序包装函数
 * @param arr 待排序数组
 */
void quickSort(std::vector<int>& arr) {
    quickSort(arr, 0, arr.size() - 1);
}

/**
 * 打印数组元素
 * @param arr 要打印的数组
 * @param msg 打印信息
 */
void printArray(const std::vector<int>& arr, const std::string& msg = "") {
    if (!msg.empty()) {
        std::cout << msg;
    }
    for (size_t i = 0; i < arr.size(); i++) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

/**
 * 主函数，用于测试快速排序算法
 */
int main() {
    std::vector<int> arr = {10, 7, 8, 9, 1, 5};
    std::cout << "========================================" << std::endl;
    std::cout << "           快速排序算法演示" << std::endl;
    std::cout << "========================================" << std::endl << std::endl;
    
    printArray(arr, "排序前: ");
    std::cout << std::endl;
    
    quickSort(arr);
    
    std::cout << "========================================" << std::endl;
    std::cout << "排序完成!" << std::endl;
    printArray(arr, "排序后: ");
    
    return 0;
}
```

## 7. 算法分析

### 7.1 时间复杂度

快速排序的时间复杂度取决于分区操作的平衡性：

- **最好情况**：每次分区都能将数组均匀分割，时间复杂度为 O(n log n)
- **平均情况**：时间复杂度为 O(n log n)
- **最坏情况**：每次分区都极不平衡（如数组已经有序），时间复杂度为 O(n²)

### 7.2 空间复杂度

- **空间复杂度**：O(log n)
- 主要来自递归调用栈的深度，在最好情况下为 O(log n)，最坏情况下为 O(n)

### 7.3 稳定性

- 快速排序是一种不稳定的排序算法
- 在分区过程中，相等元素的相对位置可能会发生变化

## 8. 算法特点

### 8.1 优点

1. **效率高**：在平均情况下，快速排序是一种非常高效的排序算法，时间复杂度为 O(n log n)
2. **原地排序**：只需要常数级别的额外空间存储临时变量
3. **实用性强**：在实际应用中表现优秀，是许多编程语言和库中默认的排序算法
4. **缓存友好**：相比于其他 O(n log n) 算法，快速排序具有更好的缓存局部性

### 8.2 缺点

1. **不稳定**：相等元素的相对位置可能发生改变
2. **最坏情况性能差**：在最坏情况下时间复杂度为 O(n²)
3. **递归实现可能导致栈溢出**：对于大规模数据，深度递归可能导致栈溢出
4. **对已基本有序的数据效率不高**：在这种情况下容易出现最坏情况

## 9. 适用场景

1. **大规模数据排序**：当需要对大量数据进行排序时，快速排序通常是首选
2. **内存受限环境**：由于是原地排序，适用于内存有限的环境
3. **一般性排序需求**：在没有特殊要求（如稳定性）的情况下，快速排序是很好的选择
4. **随机数据排序**：对于随机分布的数据，快速排序表现出色

## 10. 与其他排序算法的比较

| 排序算法 | 最好时间复杂度 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 |
|---------|---------------|---------------|---------------|-----------|--------|
| 插入排序 | O(n) | O(n²) | O(n²) | O(1) | 稳定 |
| 冒泡排序 | O(n) | O(n²) | O(n²) | O(1) | 稳定 |
| 选择排序 | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 |
| 堆排序 | O(n log n) | O(n log n) | O(n log n) | O(1) | 不稳定 |
| 快速排序 | O(n log n) | O(n log n) | O(n²) | O(log n) | 不稳定 |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | 稳定 |

## 11. 优化方案

1. **三数取中法选择基准**：从数组的第一个、中间的和最后一个元素中选择中位数作为基准，可以有效避免最坏情况
2. **随机化基准选择**：随机选择基准元素，降低出现最坏情况的概率
3. **小数组使用插入排序**：当子数组长度小于某个阈值（如10）时，使用插入排序替代快速排序
4. **尾递归优化**：将第二个递归调用改为迭代，减少递归深度
5. **三路快排**：对于有大量重复元素的数组，使用三路快排可以提高效率

## 12. 总结

快速排序是一种非常重要的排序算法，它采用分治法的思想，通过一趟排序将数组分割成两个独立的部分，然后递归地对这两部分进行排序。快速排序在平均情况下具有 O(n log n) 的时间复杂度，在实际应用中表现优异。

尽管快速排序在最坏情况下的时间复杂度为 O(n²)，并且是一种不稳定的排序算法，但通过合理的优化手段（如三数取中法选择基准、随机化等），可以大大降低出现最坏情况的概率。

掌握快速排序不仅有助于理解分治法的思想，也为后续学习更复杂的算法奠定了基础。在实际编程中，快速排序是解决排序问题的重要工具之一，很多编程语言的标准库都采用了快速排序或其变种作为默认的排序算法。