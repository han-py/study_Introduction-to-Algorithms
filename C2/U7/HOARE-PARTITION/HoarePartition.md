# Hoare划分算法 (Hoare Partition)

## 1. 算法简介

Hoare划分算法是由著名计算机科学家C.A.R. Hoare在1960年代初设计的，它是快速排序算法的原始划分方案。相比于后来的Lomuto划分方案，Hoare划分在性能上更为优秀，因为它执行的交换操作更少，特别是在处理大量重复元素时表现更好。

Hoare划分的主要特点是使用双指针从数组两端向中间扫描，通过交换操作将数组划分为两个部分，使得左侧元素不大于基准元素，右侧元素不小于基准元素。

## 2. 算法思想

Hoare划分算法的核心思想是双指针技术：

1. 选择数组的第一个元素作为基准(pivot)
2. 使用两个指针，一个从左向右扫描，一个从右向左扫描
3. 左指针寻找大于等于基准的元素，右指针寻找小于等于基准的元素
4. 当两个指针都找到目标元素后，交换这两个元素
5. 当两个指针相遇或交错时，划分过程结束

这种划分方式的一个重要特点是，基准元素在划分完成后不一定处于其最终的排序位置。

## 3. 算法步骤

### 3.1 初始设置
1. 选择数组的第一个元素作为基准元素(pivot)
2. 初始化左指针i在数组开始位置之前(i = low - 1)
3. 初始化右指针j在数组结束位置之后(j = high + 1)

### 3.2 双指针扫描
1. 移动左指针i，直到找到大于等于pivot的元素
2. 移动右指针j，直到找到小于等于pivot的元素
3. 如果i < j，则交换arr[i]和arr[j]
4. 重复上述步骤直到i >= j

### 3.3 返回分割点
当i >= j时，返回j作为分割点，数组被划分为[low, j]和[j+1, high]两部分

## 4. 算法图解示例

以数组 [10, 7, 8, 9, 1, 5] 为例演示Hoare划分过程：

```
初始状态: [10, 7, 8, 9, 1, 5]
基准元素: 10 (第一个元素)

第1轮:
- i从左向右扫描，找到10 (>= 10)
- j从右向左扫描，找到5 (<= 10)
- 交换10和5: [5, 7, 8, 9, 1, 10]

第2轮:
- i继续向右扫描，找到7 (>= 10) - 实际上7<10，继续扫描直到找到大于等于10的元素
- 更正: i扫描找到10 (>= 10)
- j向左扫描，找到1 (<= 10)
- i=0, j=4, i<j, 交换5和1: [1, 7, 8, 9, 5, 10]

第3轮:
- i继续向右扫描，找到7 (>= 10) - 实际上7<10，继续扫描直到找到大于等于10的元素
- 更正: i扫描找到10 (>= 10)
- j向左扫描，找到5 (<= 10)
- i=5, j=4, i>j, 划分结束，返回j=4

最终结果: [1, 7, 8, 9, 5] 和 [10]
```

更准确的例子，以数组 [5, 3, 8, 4, 2, 7, 1, 10] 为例：

```
初始状态: [5, 3, 8, 4, 2, 7, 1, 10]
基准元素: 5 (第一个元素)

扫描过程:
- i扫描找到8 (> 5)
- j扫描找到1 (< 5)
- 交换8和1: [5, 3, 1, 4, 2, 7, 8, 10]

继续扫描:
- i扫描找到7 (> 5)
- j扫描找到2 (< 5)
- 交换7和2: [5, 3, 1, 4, 2, 7, 8, 10]

继续扫描:
- i扫描找到8 (> 5)
- j扫描找到4 (< 5)
- i和j交错，划分结束

最终划分结果: [5, 3, 1, 4, 2] 和 [7, 8, 10]
```

## 5. 伪代码实现

```
HOARE-PARTITION(A, low, high)
1.  pivot = A[low]
2.  i = low - 1
3.  j = high + 1
4.  while TRUE
5.      repeat
6.          i = i + 1
7.      until A[i] ≥ pivot
8.      repeat
9.          j = j - 1
10.     until A[j] ≤ pivot
11.     if i ≥ j
12.         return j
13.     exchange A[i] with A[j]

QUICKSORT(A, low, high)
1.  if low < high
2.      pivotIndex = HOARE-PARTITION(A, low, high)
3.      QUICKSORT(A, low, pivotIndex)
4.      QUICKSORT(A, pivotIndex + 1, high)
```

## 6. C++代码实现

```cpp
/**
 * Hoare划分算法实现
 * @param arr 待划分的数组
 * @param low 起始索引
 * @param high 结束索引
 * @return 分割点索引
 */
int hoarePartition(std::vector<int>& arr, int low, int high) {
    // 选择第一个元素作为基准
    int pivot = arr[low];
    int i = low - 1;  // 左指针
    int j = high + 1; // 右指针
    
    while (true) {
        // 从左边找到第一个大于等于pivot的元素
        do {
            i++;
        } while (arr[i] < pivot);
        
        // 从右边找到第一个小于等于pivot的元素
        do {
            j--;
        } while (arr[j] > pivot);
        
        // 如果指针相遇或交错，则返回分割点
        if (i >= j) {
            return j;
        }
        
        // 交换元素
        std::swap(arr[i], arr[j]);
    }
}

/**
 * 快速排序主函数（使用Hoare划分）
 * @param arr 待排序数组
 * @param low 起始索引
 * @param high 结束索引
 */
void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        // 使用Hoare划分获取分割点
        int pivotIndex = hoarePartition(arr, low, high);
        
        // 递归排序分割点左右两部分
        quickSort(arr, low, pivotIndex);
        quickSort(arr, pivotIndex + 1, high);
    }
}
```

## 7. 算法分析

### 7.1 时间复杂度

- **最好情况**: O(n log n) - 每次划分都能将数组均匀分割
- **平均情况**: O(n log n) - 随机选择基准元素时的期望性能
- **最坏情况**: O(n²) - 每次选择的基准都是最大或最小元素（如已排序数组）

### 7.2 空间复杂度

- **空间复杂度**: O(log n) - 递归调用栈的深度

### 7.3 稳定性

Hoare划分算法是**不稳定**的排序算法，因为相等元素的相对位置可能会因交换操作而改变。

## 8. 算法特点

### 8.1 优点

1. **交换次数少**: 相比Lomuto划分，平均交换次数减少约三分之一
2. **处理重复元素高效**: 即使所有元素都相等也能创建有效的划分
3. **原地排序**: 只需要常数级别的额外空间
4. **广泛应用**: 是快速排序的原始设计，具有重要的历史地位

### 8.2 缺点

1. **实现复杂**: 相比Lomuto划分，理解和实现难度更大
2. **不稳定**: 不保持相等元素的原始顺序
3. **最坏情况性能差**: 在特定输入下退化为O(n²)
4. **基准位置不确定**: 基准元素在划分后不一定在其最终排序位置

## 9. 适用场景

1. **通用排序**: 适用于大多数需要排序的场景
2. **内存受限环境**: 由于是原地排序，适合内存受限的情况
3. **大数据集**: 在平均情况下具有良好的性能
4. **教学演示**: 作为分治算法和双指针技术的典型案例

## 10. 与其他划分算法比较

| 特性 | Hoare划分 | Lomuto划分 |
|------|-----------|------------|
| 发明者 | C.A.R. Hoare | Nico Lomuto |
| 时间复杂度 | O(n log n) 平均 | O(n log n) 平均 |
| 交换次数 | 较少 | 较多 |
| 实现难度 | 较难 | 较易 |
| 基准位置 | 不确定 | 固定在正确位置 |
| 稳定性 | 不稳定 | 不稳定 |

## 11. 优化方案

1. **三数取中法**: 选择首、中、尾三个元素的中位数作为基准，减少最坏情况概率
2. **随机化基准**: 随机选择基准元素，避免针对特定输入的性能退化
3. **混合算法**: 对小数组使用插入排序，对大数组使用快速排序
4. **三路划分**: 处理大量重复元素时使用三路划分提高效率

## 12. 总结

Hoare划分算法是快速排序的原始设计，体现了C.A.R. Hoare在算法设计上的深刻洞察力。该算法通过双指针技术实现了高效的数组划分，相比其他划分方案具有更少的交换次数和更好的性能表现。

虽然Hoare划分的实现相对复杂且不稳定，但它仍然是快速排序算法中最经典的划分方案之一。理解Hoare划分不仅有助于掌握快速排序的核心思想，也为学习更高级的算法设计技巧提供了良好基础。

在实际应用中，Hoare划分经常与其他优化技术结合使用，以获得更好的性能表现。对于学习算法的学生和工程师来说，掌握Hoare划分是理解分治策略和双指针技术的重要环节。