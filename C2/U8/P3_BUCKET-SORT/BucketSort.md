# 桶排序 (Bucket Sort)

## 1. 算法简介

桶排序（Bucket Sort）是《算法导论》第八章中介绍的第四种线性时间排序算法，也被称为箱排序。它是一种分布式排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。

桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。但桶排序并不是比较排序，它不受到O(n log n)下限的影响。

桶排序特别适用于输入数据均匀分布在某个范围内的情况，例如浮点数在[0,1)区间内均匀分布。

## 2. 算法思想

桶排序的核心思想是分治和分布式处理：

1. **分散（Scatter）**：将待排序的元素按照一定的规则分配到多个桶中
2. **排序（Sort）**：对每个非空桶内的元素进行排序（可以使用其他排序算法）
3. **收集（Gather）**：按照桶的顺序，将各个桶中的元素依次收集起来

桶排序的关键在于如何划分桶以及如何将元素分配到合适的桶中。理想情况下，每个桶中的元素数量应该尽可能均匀，这样可以最大化算法的效率。

## 3. 算法步骤

桶排序的具体步骤如下：

### 3.1 基本流程

1. **设置桶**：创建一定数量的空桶
2. **分配元素**：遍历原始数组，根据某种规则将每个元素放入对应的桶中
3. **桶内排序**：对每个非空桶内的元素进行排序
4. **合并结果**：按顺序遍历桶，将桶中的元素依次放回原数组

### 3.2 详细步骤

1. 根据输入数据的特点确定桶的数量和范围
2. 创建相应数量的空桶（通常使用链表或动态数组实现）
3. 遍历输入数组，根据元素值计算其应该放入的桶索引
4. 将元素放入对应桶中
5. 对每个非空桶中的元素进行排序（通常使用插入排序）
6. 按照桶的顺序，将桶中的元素依次放回原数组

## 4. 算法图解示例

以数组A = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]为例演示桶排序过程：

### 4.1 初始状态
```
输入数组A: [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]
桶数量: 10 (与元素数量相同)
桶索引范围: [0, 9]
```

### 4.2 分配元素到桶中
```
计算每个元素对应的桶索引（桶索引 = floor(n * 元素值)）：
0.78 → 桶7
0.17 → 桶1
0.39 → 桶3
0.26 → 桶2
0.72 → 桶7
0.94 → 桶9
0.21 → 桶2
0.12 → 桶1
0.23 → 桶2
0.68 → 桶6

分配后各桶内容：
桶0: []
桶1: [0.17, 0.12]
桶2: [0.26, 0.21, 0.23]
桶3: [0.39]
桶4: []
桶5: []
桶6: [0.68]
桶7: [0.78, 0.72]
桶8: []
桶9: [0.94]
```

### 4.3 桶内排序
```
对每个非空桶进行排序：
桶1: [0.12, 0.17]
桶2: [0.21, 0.23, 0.26]
桶3: [0.39]
桶6: [0.68]
桶7: [0.72, 0.78]
桶9: [0.94]
```

### 4.4 合并结果
```
按顺序收集各桶中的元素：
[0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]
```

## 5. 伪代码实现

```
BUCKET-SORT(A)
1.  n = A.length
2.  let B[0..n-1] be a new array
3.  for i = 0 to n-1
4.      make B[i] an empty list
5.  for i = 1 to n
6.      insert A[i] into list B[⌊nA[i]⌋]
7.  for i = 0 to n-1
8.      sort list B[i] with insertion sort
9.  concatenate the lists B[0], B[1], ..., B[n-1] together in order
```

## 6. C++代码实现

```cpp
/**
 * 桶排序算法实现
 * @param arr 待排序的数组，假设元素都在[0, 1)区间内
 */
void bucketSort(std::vector<float>& arr) {
    if (arr.empty()) return;
    
    int n = arr.size();
    
    // 创建n个空桶
    std::vector<std::list<float>> buckets(n);
    
    // 将数组元素分配到各个桶中
    for (int i = 0; i < n; i++) {
        // 计算元素应该放入哪个桶
        int bucketIndex = n * arr[i];
        buckets[bucketIndex].push_back(arr[i]);
    }
    
    // 对每个桶内的元素进行排序
    for (int i = 0; i < n; i++) {
        if (!buckets[i].empty()) {
            buckets[i].sort(); // 使用list自带的sort方法
        }
    }
    
    // 按顺序将各桶中的元素放回原数组
    int index = 0;
    for (int i = 0; i < n; i++) {
        for (float val : buckets[i]) {
            arr[index++] = val;
        }
    }
}
```

## 7. 算法分析

### 7.1 时间复杂度

- **最好情况**：O(n)
  - 当输入数据在各个桶中分布均匀时，每个桶中的元素很少，排序时间可以忽略不计
  
- **平均情况**：O(n)
  - 假设输入数据均匀分布，每个桶中的期望元素数量为1，桶内排序时间为O(1)
  
- **最坏情况**：O(n²)
  - 当所有元素都落入同一个桶中时，算法退化为桶内排序算法的时间复杂度（如使用插入排序则为O(n²)）

### 7.2 空间复杂度

- **空间复杂度**：O(n)
  - 需要额外的空间来存储n个桶
  - 每个桶最坏情况下可能存储所有n个元素

### 7.3 稳定性

桶排序的稳定性取决于桶内排序算法的稳定性：
- 如果桶内排序使用稳定排序算法（如插入排序），则桶排序是稳定的
- 如果桶内排序使用不稳定排序算法（如快速排序），则桶排序是不稳定的

## 8. 算法特点

### 8.1 优点

1. **时间复杂度低**：在数据均匀分布的情况下可以达到线性时间复杂度O(n)
2. **稳定性可控**：通过选择合适的桶内排序算法可以控制稳定性
3. **适合特定场景**：对于均匀分布的数据非常高效
4. **并行化**：各个桶的排序可以并行进行

### 8.2 缺点

1. **空间消耗大**：需要额外的存储空间来存储桶
2. **适用范围有限**：主要适用于数据范围已知且分布相对均匀的情况
3. **对数据分布敏感**：当数据分布不均匀时，性能会显著下降
4. **需要额外的桶内排序**：每个桶内部仍需要排序

## 9. 适用场景

1. **浮点数排序**：特别是[0,1)区间内均匀分布的浮点数
2. **数据范围已知**：事先知道数据的取值范围
3. **数据分布均匀**：输入数据在范围内分布相对均匀
4. **外部排序**：当数据量太大无法一次性加载到内存时
5. **并行处理**：可以利用多核处理器并行处理各个桶

## 10. 与其他排序算法比较

| 排序算法 | 时间复杂度(平均) | 时间复杂度(最坏) | 空间复杂度 | 稳定性 | 是否基于比较 |
|---------|----------------|----------------|-----------|--------|-------------|
| 桶排序 | O(n) | O(n²) | O(n) | 取决于子排序 | 否 |
| 快速排序 | O(n log n) | O(n²) | O(log n) | 不稳定 | 是 |
| 归并排序 | O(n log n) | O(n log n) | O(n) | 稳定 | 是 |
| 堆排序 | O(n log n) | O(n log n) | O(1) | 不稳定 | 是 |
| 计数排序 | O(n+k) | O(n+k) | O(k) | 稳定 | 否 |
| 基数排序 | O(d×(n+k)) | O(d×(n+k)) | O(n+k) | 稳定 | 否 |

## 11. 优化方案

1. **桶数量优化**：根据数据分布特点选择合适的桶数量
2. **动态桶大小**：根据实际数据分布动态调整桶的范围
3. **并行化处理**：利用多线程并行处理各个桶的排序
4. **混合算法**：当桶内元素较少时使用插入排序，较多时使用快速排序
5. **内存优化**：使用链表而非数组来实现桶，节省空间

## 12. 总结

桶排序是《算法导论》中介绍的最后一种线性时间排序算法。它通过将输入数据分散到多个桶中，然后对每个桶单独排序，最后合并结果的方式来实现排序。桶排序的效率很大程度上取决于输入数据的分布情况。

桶排序的核心思想体现了分治法和分布式处理的理念，通过将大规模问题分解为多个小规模问题来解决。这种思想在计算机科学的很多领域都有应用，如分布式计算、并行处理等。

在实际应用中，桶排序特别适用于处理浮点数排序或数据范围已知且分布均匀的场景。但需要注意的是，桶排序对数据分布非常敏感，当数据分布不均匀时，其性能可能会显著下降。

理解和掌握桶排序有助于我们认识到并非所有排序都必须基于元素比较，合理利用数据的分布特性可以设计出更高效的算法。桶排序与计数排序、基数排序一起构成了线性时间排序算法的基础，为处理特定类型的数据提供了有效的解决方案。