# 计数排序 (Counting Sort)

## 1. 算法简介

计数排序（Counting Sort）是《算法导论》第八章中介绍的一种线性时间排序算法，它是一种非比较型排序算法。与快速排序、归并排序等基于比较的排序算法不同，计数排序不通过比较元素来确定它们的相对次序，而是通过计算元素的出现次数来确定每个元素的正确位置。

计数排序假设n个输入元素中的每一个都是在0到k区间内的整数，其中k为某个整数。当k=O(n)时，计数排序的运行时间为Θ(n)。这是一种非常高效的排序算法，特别适用于元素范围较小的情况。

## 2. 算法思想

计数排序的核心思想是将输入的数据值转化为键存储在额外开辟的数组空间中。具体来说：

1. 使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数
2. 根据数组C来确定每个元素在输出数组中的位置
3. 通过统计每个元素的出现次数，直接把元素放到输出数组中的正确位置

这种方法避免了元素间的比较操作，从而实现了线性时间复杂度。

## 3. 算法步骤

计数排序的具体步骤如下：

### 3.1 基本版本（假设元素范围为0到k）

1. **初始化计数数组**：创建一个大小为k+1的数组C，并将所有元素初始化为0
2. **统计元素频次**：遍历输入数组A，对于每个元素A[i]，将C[A[i]]的值增加1
3. **计算累积计数**：将计数数组C转换为累积计数数组，使C[i]表示小于等于i的元素个数
4. **构建输出数组**：从右到左遍历输入数组A，根据累积计数数组确定每个元素在输出数组中的位置
5. **复制结果**：将排序后的结果复制回原数组或返回新数组

### 3.2 改进版本（处理任意范围整数）

1. **确定范围**：找出输入数组中的最大值和最小值
2. **计算范围大小**：range = max - min + 1
3. **创建计数数组**：创建大小为range的计数数组
4. **统计元素频次**：遍历输入数组，统计每个元素出现的次数
5. **计算累积计数**：将计数数组转换为累积计数数组
6. **构建输出数组**：根据累积计数数组构建排序后的数组

## 4. 算法图解示例

以数组A = [2, 5, 3, 0, 2, 3, 0, 3]为例演示计数排序过程：

### 4.1 初始状态
```
输入数组A: [2, 5, 3, 0, 2, 3, 0, 3]
最大值k: 5
计数数组C: [0, 0, 0, 0, 0, 0] (大小为k+1=6)
输出数组B: [0, 0, 0, 0, 0, 0, 0, 0] (大小为n=8)
```

### 4.2 统计元素频次
```
遍历数组A，统计每个元素出现次数：
A[0]=2 => C[2]++ => C=[0, 0, 1, 0, 0, 0]
A[1]=5 => C[5]++ => C=[0, 0, 1, 0, 0, 1]
A[2]=3 => C[3]++ => C=[0, 0, 1, 1, 0, 1]
A[3]=0 => C[0]++ => C=[1, 0, 1, 1, 0, 1]
A[4]=2 => C[2]++ => C=[1, 0, 2, 1, 0, 1]
A[5]=3 => C[3]++ => C=[1, 0, 2, 2, 0, 1]
A[6]=0 => C[0]++ => C=[2, 0, 2, 2, 0, 1]
A[7]=3 => C[3]++ => C=[2, 0, 2, 3, 0, 1]
```

### 4.3 计算累积计数
```
将C转换为累积计数数组：
C[0]=2
C[1]=C[1]+C[0]=0+2=2
C[2]=C[2]+C[1]=2+2=4
C[3]=C[3]+C[2]=3+4=7
C[4]=C[4]+C[3]=0+7=7
C[5]=C[5]+C[4]=1+7=8

最终C=[2, 2, 4, 7, 7, 8]
```

### 4.4 构建输出数组
```
从右到左遍历A，确定每个元素在B中的位置：
A[7]=3 => B[C[3]-1]=B[6]=3, C[3]-- => C[3]=6
A[6]=0 => B[C[0]-1]=B[1]=0, C[0]-- => C[0]=1
A[5]=3 => B[C[3]-1]=B[5]=3, C[3]-- => C[3]=5
A[4]=2 => B[C[2]-1]=B[3]=2, C[2]-- => C[2]=3
A[3]=0 => B[C[0]-1]=B[0]=0, C[0]-- => C[0]=0
A[2]=3 => B[C[3]-1]=B[4]=3, C[3]-- => C[3]=4
A[1]=5 => B[C[5]-1]=B[7]=5, C[5]-- => C[5]=7
A[0]=2 => B[C[2]-1]=B[2]=2, C[2]-- => C[2]=2

最终输出数组B=[0, 0, 2, 2, 3, 3, 3, 5]
```

## 5. 伪代码实现

```
COUNTING-SORT(A, B, k)
1.  let C[0..k] be a new array
2.  for i = 0 to k
3.      C[i] = 0
4.  for j = 1 to A.length
5.      C[A[j]] = C[A[j]] + 1
6.  // C[i] now contains the number of elements equal to i
7.  for i = 1 to k
8.      C[i] = C[i] + C[i-1]
9.  // C[i] now contains the number of elements less than or equal to i
10. for j = A.length downto 1
11.     B[C[A[j]]] = A[j]
12.     C[A[j]] = C[A[j]] - 1
```

## 6. C++代码实现

```cpp
/**
 * 计数排序算法实现（针对非负整数）
 * @param arr 待排序的数组
 * @param k 数组中元素的最大值
 */
void countingSort(std::vector<int>& arr, int k) {
    int n = arr.size();
    
    // 创建计数数组和输出数组
    std::vector<int> count(k + 1, 0);
    std::vector<int> output(n);
    
    // 统计每个元素出现的次数
    for (int i = 0; i < n; i++) {
        count[arr[i]]++;
    }
    
    // 将计数数组转换为累积计数数组
    for (int i = 1; i <= k; i++) {
        count[i] += count[i - 1];
    }
    
    // 构建输出数组（从右到左遍历保证稳定性）
    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;
    }
    
    // 将排序结果复制回原数组
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}

/**
 * 计数排序算法实现（处理任意范围整数）
 * @param arr 待排序的数组
 * @return 排序后的数组
 */
std::vector<int> countingSort(const std::vector<int>& arr) {
    if (arr.empty()) return arr;
    
    // 找到数组中的最大值和最小值
    int maxVal = *std::max_element(arr.begin(), arr.end());
    int minVal = *std::min_element(arr.begin(), arr.end());
    
    // 计算计数数组的大小
    int range = maxVal - minVal + 1;
    
    // 创建计数数组并初始化为0
    std::vector<int> count(range, 0);
    
    // 统计每个元素出现的次数
    for (int num : arr) {
        count[num - minVal]++;
    }
    
    // 将计数数组转换为累积计数数组
    for (int i = 1; i < range; i++) {
        count[i] += count[i - 1];
    }
    
    // 创建输出数组
    std::vector<int> output(arr.size());
    
    // 从右到左遍历原数组，构建排序后的数组
    for (int i = arr.size() - 1; i >= 0; i--) {
        output[count[arr[i] - minVal] - 1] = arr[i];
        count[arr[i] - minVal]--;
    }
    
    return output;
}
```

## 7. 算法分析

### 7.1 时间复杂度

- **最好情况**：O(n + k)
- **平均情况**：O(n + k)
- **最坏情况**：O(n + k)

其中n是待排序元素的数量，k是数据的范围大小。当k = O(n)时，计数排序的运行时间为Θ(n)。

### 7.2 空间复杂度

- **空间复杂度**：O(k)
  - 需要额外的计数数组C，大小为k+1
  - 需要额外的输出数组B，大小为n

### 7.3 稳定性

计数排序是一种**稳定**的排序算法。通过从右到左遍历输入数组并在计数数组中递减计数，可以保证相等元素的相对顺序在排序后保持不变。

## 8. 算法特点

### 8.1 优点

1. **时间复杂度低**：在适当条件下可以达到线性时间复杂度O(n)
2. **稳定性**：是一种稳定的排序算法
3. **实现简单**：算法逻辑清晰，易于理解和实现
4. **适合特定场景**：对于范围较小的整数排序非常高效

### 8.2 缺点

1. **空间消耗大**：需要额外的存储空间，空间复杂度为O(k)
2. **适用范围有限**：只适用于整数或可以映射为整数的数据
3. **对数据范围敏感**：当k远大于n时，效率会显著下降
4. **不适用于浮点数**：无法直接处理浮点数排序

## 9. 适用场景

1. **整数排序**：当需要排序的数据是整数且范围不是很大时
2. **数据范围已知**：事先知道数据的取值范围
3. **大量重复元素**：数据中有大量重复元素的情况
4. **作为其他算法的子程序**：基数排序等算法的基础
5. **对稳定性有要求**：需要保持相等元素相对顺序的场景

## 10. 与其他排序算法比较

| 排序算法 | 时间复杂度(平均) | 时间复杂度(最坏) | 空间复杂度 | 稳定性 | 是否基于比较 |
|---------|----------------|----------------|-----------|--------|-------------|
| 计数排序 | O(n+k) | O(n+k) | O(k) | 稳定 | 否 |
| 快速排序 | O(n log n) | O(n²) | O(log n) | 不稳定 | 是 |
| 归并排序 | O(n log n) | O(n log n) | O(n) | 稳定 | 是 |
| 堆排序 | O(n log n) | O(n log n) | O(1) | 不稳定 | 是 |
| 插入排序 | O(n²) | O(n²) | O(1) | 稳定 | 是 |

## 11. 优化方案

1. **范围优化**：通过找到数组中的最大值和最小值来减小计数数组的大小
2. **内存优化**：当k很大时，可以考虑使用哈希表代替数组来存储计数
3. **并行化**：在统计频次和构建输出数组阶段可以并行处理
4. **与基数排序结合**：对于大范围整数，可以使用基数排序结合计数排序

## 12. 总结

计数排序是《算法导论》中介绍的第一种线性时间排序算法，它展示了非比较排序算法的强大之处。通过牺牲空间复杂度来换取时间复杂度的优势，计数排序在特定场景下表现非常出色。

该算法的核心思想是利用数据本身的特性（整数且范围有限），通过统计元素出现次数而非比较元素大小的方式来实现排序。这种思想为后续的基数排序、桶排序等线性时间排序算法奠定了基础。

在实际应用中，计数排序特别适合处理大量数据但数据范围有限的场景，例如年龄排序、成绩排序等。然而，对于数据范围很大或者数据类型不是整数的情况，计数排序就不适用了，这时需要考虑其他排序算法。

理解和掌握计数排序不仅有助于学习更高级的排序算法，还能培养我们根据不同问题特点选择合适算法的思维能力。