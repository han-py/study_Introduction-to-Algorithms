# 基数排序 (Radix Sort)

## 1. 算法简介

基数排序（Radix Sort）是《算法导论》第八章中介绍的第三种线性时间排序算法。它是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。

基数排序可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不只是能使用于整数。

基数排序的基本思想是：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

## 2. 算法思想

基数排序的核心思想是按数字的每一位进行排序，利用稳定排序算法来保证最终结果的正确性。具体来说：

1. 从最低位（个位）开始，对数组按当前位上的数字进行稳定排序
2. 依次处理十位、百位……直到最高位
3. 每一位的排序都使用稳定排序算法（通常是计数排序）
4. 由于稳定排序的性质，经过所有位的排序后，整个数组就变得有序了

基数排序的关键在于必须使用稳定排序算法来处理每一位，这样才能保证之前已经排好序的位不会被打乱。

## 3. 算法步骤

基数排序的具体步骤如下：

### 3.1 基本流程

1. **确定最大数的位数**：找出数组中最大数，确定其位数d
2. **从低位到高位依次排序**：对每一位（从个位到最高位）进行稳定排序
3. **使用稳定排序算法**：每一位的排序都使用稳定排序算法（如计数排序）

### 3.2 详细步骤

1. 找出数组中最大的数，确定其位数
2. 从个位开始，对每一位执行以下操作：
   - 使用稳定排序算法（如计数排序）对该位进行排序
   - 保持之前已排序的位的相对顺序不变
3. 重复步骤2，直到处理完最高位

### 3.3 排序方向

基数排序有两种方式：
- **LSD（Least Significant Digit first）**：从最低位开始排序，这是最常见的做法
- **MSD（Most Significant Digit first）**：从最高位开始排序

## 4. 算法图解示例

以数组A = [329, 457, 657, 839, 436, 720, 355]为例演示基数排序过程：

### 4.1 初始状态
```
输入数组A: [329, 457, 657, 839, 436, 720, 355]
最大数: 839
位数: 3
```

### 4.2 按个位排序
```
按个位数字排序：
329(9) 457(7) 657(7) 839(9) 436(6) 720(0) 355(5)

使用稳定排序后：
720(0) 355(5) 436(6) 457(7) 657(7) 329(9) 839(9)

结果: [720, 355, 436, 457, 657, 329, 839]
```

### 4.3 按十位排序
```
按十位数字排序：
720(2) 355(5) 436(3) 457(5) 657(5) 329(2) 839(3)

使用稳定排序后：
720(2) 329(2) 436(3) 839(3) 355(5) 457(5) 657(5)

结果: [720, 329, 436, 839, 355, 457, 657]
```

### 4.4 按百位排序
```
按百位数字排序：
720(7) 329(3) 436(4) 839(8) 355(3) 457(4) 657(6)

使用稳定排序后：
329(3) 355(3) 436(4) 457(4) 657(6) 720(7) 839(8)

最终结果: [329, 355, 436, 457, 657, 720, 839]
```

## 5. 伪代码实现

```
RADIX-SORT(A, d)
1.  for i = 1 to d
2.      use a stable sort to sort array A on digit i
```

其中，d是数字的最大位数，第1位是最右边的位（个位）。

## 6. C++代码实现

```cpp
/**
 * 获取数字中指定位上的数字
 * @param num 数字
 * @param digit 位数（从右往左数，从1开始）
 * @return 指定位上的数字
 */
int getDigit(int num, int digit) {
    for (int i = 1; i < digit; i++) {
        num /= 10;
    }
    return num % 10;
}

/**
 * 获取数组中最大数的位数
 * @param arr 数组
 * @return 最大数的位数
 */
int getMaxDigits(const std::vector<int>& arr) {
    int maxVal = *std::max_element(arr.begin(), arr.end());
    int digits = 0;
    while (maxVal > 0) {
        maxVal /= 10;
        digits++;
    }
    return digits;
}

/**
 * 计数排序（针对指定位）
 * @param arr 待排序数组
 * @param digit 位数（从右往左数，从1开始）
 */
void countingSortForRadix(std::vector<int>& arr, int digit) {
    int n = arr.size();
    std::vector<int> output(n);
    std::vector<int> count(10, 0); // 0-9十个数字
    
    // 统计当前位上各数字出现的次数
    for (int i = 0; i < n; i++) {
        int d = getDigit(arr[i], digit);
        count[d]++;
    }
    
    // 计算累积计数
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }
    
    // 构建输出数组（从右到左遍历保证稳定性）
    for (int i = n - 1; i >= 0; i--) {
        int d = getDigit(arr[i], digit);
        output[count[d] - 1] = arr[i];
        count[d]--;
    }
    
    // 将排序结果复制回原数组
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}

/**
 * 基数排序算法实现
 * @param arr 待排序的数组
 */
void radixSort(std::vector<int>& arr) {
    if (arr.empty()) return;
    
    // 获取最大数的位数
    int maxDigits = getMaxDigits(arr);
    
    // 对每一位进行计数排序
    for (int digit = 1; digit <= maxDigits; digit++) {
        countingSortForRadix(arr, digit);
    }
}
```

## 7. 算法分析

### 7.1 时间复杂度

- **时间复杂度**：O(d × (n + k))
  - 其中n是排序元素个数，d是数字位数，k是每一位可能的取值范围（对于十进制数k=10）
  - 需要进行d轮排序，每轮排序使用计数排序，时间复杂度为O(n + k)

在大多数实际情况下，d可以认为是一个较小的常数，因此基数排序的时间复杂度可以近似为O(n)。

### 7.2 空间复杂度

- **空间复杂度**：O(n + k)
  - 需要额外的输出数组空间O(n)
  - 需要计数数组空间O(k)，其中k是每一位的取值范围

### 7.3 稳定性

基数排序是一种**稳定**的排序算法。这是因为：
1. 每一位都使用稳定排序算法进行排序
2. 从低位到高位依次排序，高位排序时保持低位已排序的相对顺序

## 8. 算法特点

### 8.1 优点

1. **时间复杂度低**：在适当条件下可以达到线性时间复杂度O(n)
2. **稳定性**：是一种稳定的排序算法
3. **适合特定场景**：对于整数或固定长度字符串排序非常高效
4. **可并行化**：每一位的计数可以并行进行

### 8.2 缺点

1. **空间消耗大**：需要额外的存储空间
2. **适用范围有限**：主要适用于整数或可以映射为整数的数据
3. **对数据范围敏感**：当位数d很大时，效率会受到影响
4. **依赖稳定排序**：必须使用稳定排序算法作为子程序

## 9. 适用场景

1. **整数排序**：当需要排序的数据是整数时
2. **固定长度字符串排序**：如等长的人名、日期等
3. **数据位数较少**：当数据的位数相对较少时效果最好
4. **大量数据排序**：当数据量很大且满足上述条件时
5. **对稳定性有要求**：需要保持相等元素相对顺序的场景

## 10. 与其他排序算法比较

| 排序算法 | 时间复杂度(平均) | 时间复杂度(最坏) | 空间复杂度 | 稳定性 | 是否基于比较 |
|---------|----------------|----------------|-----------|--------|-------------|
| 基数排序 | O(d×(n+k)) | O(d×(n+k)) | O(n+k) | 稳定 | 否 |
| 快速排序 | O(n log n) | O(n²) | O(log n) | 不稳定 | 是 |
| 归并排序 | O(n log n) | O(n log n) | O(n) | 稳定 | 是 |
| 堆排序 | O(n log n) | O(n log n) | O(1) | 不稳定 | 是 |
| 计数排序 | O(n+k) | O(n+k) | O(k) | 稳定 | 否 |

## 11. 优化方案

1. **位数优化**：预先计算最大数的位数，避免重复计算
2. **内存优化**：原地基数排序可以减少空间使用
3. **并行化**：对每一位的计数可以并行处理
4. **基数选择**：可以选择不同的基数（如256）来减少排序轮数
5. **混合算法**：当数据量较小时切换到其他排序算法

## 12. 总结

基数排序是《算法导论》中介绍的第三种线性时间排序算法，也是最后一种。它展示了通过巧妙地利用数据特性和稳定排序算法，可以突破比较排序的Ω(n log n)时间下界。

基数排序的核心思想是按位排序，通过多次稳定排序来实现整体有序。它要求每一位的排序都必须是稳定的，这是保证算法正确性的关键。

在实际应用中，基数排序特别适合处理大量整数数据的排序，尤其是在数据位数较少的情况下。然而，对于位数很多或者数据类型不是整数的情况，基数排序就不适用了。

理解和掌握基数排序有助于我们认识到并非所有排序都必须基于比较，合理利用数据的特性可以设计出更高效的算法。基数排序与计数排序、桶排序一起构成了线性时间排序算法的基础，为处理大量数据提供了有效的解决方案。