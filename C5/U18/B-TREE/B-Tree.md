# B树 (B-Tree)

> 📘 _算法导论第18章学习指南_

## 🎯 1. 简介

**B树**(B-Tree)是一种自平衡的树数据结构，能够保持数据有序，并允许在对数时间内进行搜索、顺序访问、插入和删除操作。B树是专门为磁盘或其他直接访问辅助存储设备而设计的，它是数据库和文件系统中非常重要的数据结构。

B树的特点：
- 所有叶子节点都在同一层
- 除了根节点外，每个节点都包含至少⌈m/2⌉-1个关键字（其中m是最小度数）
- 每个节点最多包含m-1个关键字
- 节点的关键字按升序排列
- 对于内部节点，子节点的数量比关键字数量多1

## 📚 2. B树的定义

一棵最小度数为t的B树是一棵具有以下性质的树：

1. **根节点性质**：
   - 根节点至少包含1个关键字
   - 根节点如果不是叶节点，至少有2个子节点

2. **内部节点性质**：
   - 每个内部节点（除根节点外）至少包含t-1个关键字
   - 每个内部节点至多包含2t-1个关键字
   - 如果一个节点有n个关键字，则它有n+1个子节点

3. **叶节点性质**：
   - 所有叶节点都在同一深度

4. **关键字性质**：
   - 节点内的关键字按升序排列
   - 对于任意关键字k，其左子树的所有关键字都小于k，右子树的所有关键字都大于k

## 🔧 3. B树的操作

### 3.1 搜索操作

B树的搜索类似于二叉搜索树的搜索，但每个节点可以有多个关键字：

```
B-TREE-SEARCH(x, k)
1. i = 1
2. while i ≤ x.n and k > x.key_i
3.     i = i + 1
4. if i ≤ x.n and k == x.key_i
5.     return (x, i)
6. else if x.leaf
7.     return NIL
8. else
9.     DISK-READ(x.c_i)
10.    return B-TREE-SEARCH(x.c_i, k)
```

### 3.2 插入操作

插入操作比较复杂，因为可能需要分裂节点：

1. **创建根节点**：如果树为空，创建一个新的根节点
2. **检查根节点是否满**：如果根节点已满（包含2t-1个关键字），则分裂根节点
3. **向下递归插入**：沿着树向下递归，必要时分裂满节点

```
B-TREE-INSERT(T, k)
1. r = T.root
2. if r.n == 2t-1
3.     s = ALLOCATE-NODE()
4.     T.root = s
5.     s.leaf = FALSE
6.     s.n = 0
7.     s.c_1 = r
8.     B-TREE-SPLIT-CHILD(s, 1)
9.     B-TREE-INSERT-NONFULL(s, k)
10.else
11.    B-TREE-INSERT-NONFULL(r, k)
```

### 3.3 删除操作

删除操作更为复杂，因为它需要维护B树的性质：

1. **从叶节点删除**：如果关键字在叶节点中，直接删除
2. **从内部节点删除**：
   - 如果关键字的左子树有足够的关键字，用前驱替换
   - 如果关键字的右子树有足够的关键字，用后继替换
   - 否则合并两个子树
3. **处理下溢**：如果删除后某个节点的关键字数量不足，需要从兄弟节点借关键字或合并节点

## 🧱 4. B树的节点结构

```
typedef struct BTreeNode {
    bool leaf;                 // 是否为叶节点
    int n;                     // 当前关键字数量
    int keys[2*t-1];          // 存储关键字的数组
    struct BTreeNode* c[2*t]; // 存储子节点指针的数组
} BTreeNode;
```

## 📊 5. 时间复杂度分析

| 操作 | 磁盘访问次数 | CPU时间复杂度 |
|------|-------------|--------------|
| 搜索 | O(log_t n) | O(t log_t n) |
| 插入 | O(log_t n) | O(t log_t n) |
| 删除 | O(log_t n) | O(t log_t n) |

其中n是树中关键字的总数，t是最小度数。

## 💡 6. B树的优势

### 6.1 磁盘访问优化

B树的设计特别适合磁盘存储，原因如下：

1. **减少磁盘访问次数**：由于每个节点可以存储多个关键字，树的高度相对较低，减少了磁盘访问次数
2. **局部性原理**：一次磁盘读取可以获取整个节点的信息，充分利用了磁盘的批量传输特性
3. **缓存友好**：相邻的关键字通常存储在同一节点中，有利于缓存利用

### 6.2 自平衡特性

B树始终保持平衡，这意味着所有叶子节点都在同一深度，保证了操作的时间复杂度始终是对数级别的。

## 🧪 7. 示例代码解析

我们的示例代码展示了B树的核心概念：

1. **BTreeNode类**：表示B树的节点，包含关键字数组和子节点指针数组
2. **BTree类**：表示整个B树，包含指向根节点的指针和最小度数
3. **核心操作**：
   - [splitChild](file://C:\Users\HaPpY\Desktop\study_Introduction-to-Algorithms\C5\U18\B-TREE\B-Tree.cpp#L115-L153)：分裂满子节点
   - [insertNonFull](file://C:\Users\HaPpY\Desktop\study_Introduction-to-Algorithms\C5\U18\B-TREE\B-Tree.cpp#L156-L183)：向非满节点插入关键字
   - [remove](file://C:\Users\HaPpY\Desktop\study_Introduction-to-Algorithms\C5\U18\B-TREE\B-Tree.cpp#L252-L271)：从节点中删除关键字
   - [fill](file://C:\Users\HaPpY\Desktop\study_Introduction-to-Algorithms\C5\U18\B-TREE\B-Tree.cpp#L332-L347)：填充子节点的关键字数量

## 📈 8. B树变体

### 8.1 B+树

B+树是B树的一种变体，广泛应用于数据库和文件系统中：

- 所有关键字都出现在叶节点中
- 内部节点只存储索引信息
- 叶节点通过指针连接形成有序链表

### 8.2 B*树

B*树是B树的另一种变体：

- 非根节点和非叶节点至少填充2/3而不是1/2
- 当节点满时，尝试将其关键字重新分布到兄弟节点
- 只有在兄弟节点也满的情况下才进行分裂

## 🎯 9. 应用场景

B树广泛应用于各种系统中：

1. **数据库系统**：大多数关系数据库管理系统使用B树或其变体作为索引结构
2. **文件系统**：NTFS、HFS+、ext4等文件系统使用B树组织文件和目录
3. **操作系统**：页表管理、虚拟内存管理等
4. **搜索引擎**：倒排索引等数据结构

## ⚠️ 10. 实现注意事项

1. **内存管理**：B树涉及大量动态内存分配，需要注意内存泄漏问题
2. **边界条件**：正确处理根节点为空、只有一个节点等情况
3. **参数选择**：合理选择最小度数t，平衡内存使用和性能
4. **并发控制**：在多线程环境下，需要适当的锁机制保护B树结构

## 🧠 11. 总结

B树是一种非常重要的数据结构，特别适用于需要频繁磁盘访问的应用场景。它的设计充分考虑了磁盘I/O的特性，通过最大化每个节点存储的关键字数量来降低树的高度，从而减少磁盘访问次数。

理解B树的工作原理不仅有助于我们更好地使用数据库和文件系统，也为学习更高级的数据结构奠定了基础。虽然B树的实现较为复杂，特别是删除操作，但其强大的功能和优秀的性能使其成为许多系统的核心组件。

通过我们的示例代码，您可以清楚地看到B树的各种操作是如何实现的，包括节点分裂、关键字插入和删除等核心功能。这为深入学习和实践提供了坚实的基础。